File "parser_php.mly", line 81, characters 22-32:
Warning: the token TCommentPP is unused.
File "parser_php.mly", line 75, characters 30-38:
Warning: the token TNewline is unused.
File "parser_php.mly", line 75, characters 22-29:
Warning: the token TSpaces is unused.
File "parser_php.mly", line 68, characters 22-30:
Warning: the token TUnknown is unused.
File "parser_php.mly", line 174, characters 22-36:
Warning: the token T_CLASS_XDEBUG is unused.
File "parser_php.mly", line 138, characters 13-24:
Warning: the token T_CLOSE_TAG is unused.
File "parser_php.mly", line 78, characters 22-31:
Warning: the token T_COMMENT is unused.
File "parser_php.mly", line 78, characters 32-45:
Warning: the token T_DOC_COMMENT is unused.
File "parser_php.mly", line 138, characters 1-11:
Warning: the token T_OPEN_TAG is unused.
File "parser_php.mly", line 174, characters 38-55:
Warning: the token T_RESOURCE_XDEBUG is unused.
%{
(* src: originally ocamlyaccified from zend_language_parser.y in Zend PHP.
 * updates:
 *  - extended to deal with XHP based on the XHP bison grammar
 *  - added support for a few PHP 5.3 extensions (e.g. lambda, const), but
 *    not namespace
 *  - added support for yield (facebook extension)
 *  - added support for a few PHP 5.4 extensions (e.g. traits, short array)
 *  - added support for generics (another facebook extension)
 *  - added support for attributes (a.k.a annotations)
 *  - factorized some rules (e.g. parameters, arguments)
 *  - added support for trailing comma in function calls and definitions
 *  - added support for (new Foo)->method() (id() not needed anymore)
 *  - heavy rewrite of expr and lvalue rules, to avoid the many conflicts
 *    regarding f()[] sugar and also to allow more forms of expressions
 *    such as (<whatever expr>)->method()
 *  - added support for typedefs (another facebook extension)
 *  - added support for implicit fields via constructor parameters
 *    (facebook extension)
 *  - added support for namespace (a PHP 5.3 extension)
 /*
  * +----------------------------------------------------------------------+
  * | Zend Engine                                                          |
  * +----------------------------------------------------------------------+
  * | Copyright (c) 1998-2006 Zend Technologies Ltd. (http://www.zend.com) |
  * +----------------------------------------------------------------------+
  * | This source file is subject to version 2.00 of the Zend license,     |
  * | that is bundled with this package in the file LICENSE, and is        |
  * | available through the world-wide-web at the following url:           |
  * | http://www.zend.com/license/2_00.txt.                                |
  * | If you did not receive a copy of the Zend license and are unable to  |
  * | obtain it through the world-wide-web, please send a note to          |
  * | license@zend.com so we can mail you a copy immediately.              |
  * +----------------------------------------------------------------------+
  * | Authors: Andi Gutmans <andi@zend.com>                                |
  * |          Zeev Suraski <zeev@zend.com>                                |
  * +----------------------------------------------------------------------+
  */
 *)
open Common

open Ast_php
module Ast = Ast_php
module H = Parser_php_mly_helper
module PI = Parse_info

%}
%start main
%start sgrep_spatch_pattern
%token <Ast_php.info> EOF
%token <Ast_php.info> TAND
%token <Ast_php.info> TANTISLASH
%token <Ast_php.info> TBACKQUOTE
%token <Ast_php.info> TBANG
%token <Ast_php.info> TCBRA
%token <Ast_php.info> TCBRACE
%token <Ast_php.info> TCOLCOL
%token <Ast_php.info> TCOLON
%token <Ast_php.info> TCOMMA
%token <Ast_php.info> TCPAR
%token <Ast_php.info> TCommentPP
%token <Ast_php.info> TDIV
%token <Ast_php.info> TDOLLAR
%token <Ast_php.info> TDOT
%token <Ast_php.info> TEQ
%token <Ast_php.info> TGREATER
%token <Ast_php.info> TGUIL
%token <Ast_php.info> TMINUS
%token <Ast_php.info> TMOD
%token <Ast_php.info> TMUL
%token <Ast_php.info> TNewline
%token <Ast_php.info> TOBRA
%token <Ast_php.info> TOBRACE
%token <Ast_php.info> TOPAR
%token <Ast_php.info> TOR
%token <Ast_php.info> TPLUS
%token <Ast_php.info> TQUESTION
%token <Ast_php.info> TSEMICOLON
%token <Ast_php.info> TSMALLER
%token <Ast_php.info> TSpaces
%token <Ast_php.info> TTILDE
%token <Ast_php.info> TUnknown
%token <Ast_php.info> TXOR
%token <Ast_php.info> T_ABSTRACT
%token <Ast_php.info> T_AND_EQUAL
%token <Ast_php.info> T_ARRAY
%token <Ast_php.info> T_ARRAY_CAST
%token <Ast_php.info> T_ARROW
%token <Ast_php.info> T_AS
%token <Ast_php.info> T_ASYNC
%token <Ast_php.info> T_AWAIT
%token <Ast_php.info> T_BOOLEAN_AND
%token <Ast_php.info> T_BOOLEAN_OR
%token <Ast_php.info> T_BOOL_CAST
%token <Ast_php.info> T_BREAK
%token <Ast_php.info> T_CASE
%token <Ast_php.info> T_CATCH
%token <Ast_php.info> T_CLASS
%token <Ast_php.info> T_CLASS_C
%token <Ast_php.info> T_CLASS_XDEBUG
%token <Ast_php.info> T_CLONE
%token <Ast_php.info> T_CLOSE_TAG
%token <Ast_php.info> T_CLOSE_TAG_OF_ECHO
%token <Ast_php.info> T_COMMENT
%token <Ast_php.info> T_CONCAT_EQUAL
%token <Ast_php.info> T_CONST
%token <string * Ast_php.info> T_CONSTANT_ENCAPSED_STRING
%token <Ast_php.info> T_CONTINUE
%token <Ast_php.info> T_CURLY_OPEN
%token <Ast_php.info> T_DEC
%token <Ast_php.info> T_DECLARE
%token <Ast_php.info> T_DEFAULT
%token <Ast_php.info> T_DIR
%token <Ast_php.info> T_DIV_EQUAL
%token <string * Ast_php.info> T_DNUMBER
%token <Ast_php.info> T_DO
%token <Ast_php.info> T_DOC_COMMENT
%token <Ast_php.info> T_DOLLAR_OPEN_CURLY_BRACES
%token <Ast_php.info> T_DOUBLE_ARROW
%token <Ast_php.info> T_DOUBLE_CAST
%token <Ast_php.info> T_ECHO
%token <Ast_php.info> T_ELLIPSIS
%token <Ast_php.info> T_ELSE
%token <Ast_php.info> T_ELSEIF
%token <Ast_php.info> T_EMPTY
%token <string * Ast_php.info> T_ENCAPSED_AND_WHITESPACE
%token <Ast_php.info> T_ENDDECLARE
%token <Ast_php.info> T_ENDFOR
%token <Ast_php.info> T_ENDFOREACH
%token <Ast_php.info> T_ENDIF
%token <Ast_php.info> T_ENDSWITCH
%token <Ast_php.info> T_ENDWHILE
%token <Ast_php.info> T_END_HEREDOC
%token <Ast_php.info> T_ENUM
%token <Ast_php.info> T_EVAL
%token <Ast_php.info> T_EXIT
%token <Ast_php.info> T_EXTENDS
%token <Ast_php.info> T_FILE
%token <Ast_php.info> T_FINAL
%token <Ast_php.info> T_FINALLY
%token <Ast_php.info> T_FOR
%token <Ast_php.info> T_FOREACH
%token <Ast_php.info> T_FUNCTION
%token <Ast_php.info> T_FUNC_C
%token <Ast_php.info> T_GLOBAL
%token <string * Ast_php.info> T_IDENT
%token <Ast_php.info> T_IF
%token <Ast_php.info> T_IMPLEMENTS
%token <Ast_php.info> T_INC
%token <Ast_php.info> T_INCLUDE
%token <Ast_php.info> T_INCLUDE_ONCE
%token <string * Ast_php.info> T_INLINE_HTML
%token <Ast_php.info> T_INSTANCEOF
%token <Ast_php.info> T_INSTEADOF
%token <Ast_php.info> T_INTERFACE
%token <Ast_php.info> T_INT_CAST
%token <Ast_php.info> T_ISSET
%token <Ast_php.info> T_IS_EQUAL
%token <Ast_php.info> T_IS_GREATER_OR_EQUAL
%token <Ast_php.info> T_IS_IDENTICAL
%token <Ast_php.info> T_IS_NOT_EQUAL
%token <Ast_php.info> T_IS_NOT_IDENTICAL
%token <Ast_php.info> T_IS_SMALLER_OR_EQUAL
%token <Ast_php.info> T_LAMBDA_CPAR
%token <Ast_php.info> T_LAMBDA_OPAR
%token <Ast_php.info> T_LINE
%token <Ast_php.info> T_LIST
%token <string * Ast_php.info> T_LNUMBER
%token <Ast_php.info> T_LOGICAL_AND
%token <Ast_php.info> T_LOGICAL_OR
%token <Ast_php.info> T_LOGICAL_XOR
%token <Ast_php.info> T_METHOD_C
%token <Ast_php.info> T_MINUS_EQUAL
%token <Ast_php.info> T_MOD_EQUAL
%token <Ast_php.info> T_MUL_EQUAL
%token <Ast_php.info> T_NAMESPACE
%token <Ast_php.info> T_NAMESPACE_C
%token <Ast_php.info> T_NEW
%token <Ast_php.info> T_NEWTYPE
%token <string * Ast_php.info> T_NUM_STRING
%token <Ast_php.info> T_OBJECT_CAST
%token <Ast_php.info> T_OBJECT_OPERATOR
%token <Ast_php.info> T_OPEN_TAG
%token <Ast_php.info> T_OPEN_TAG_WITH_ECHO
%token <Ast_php.info> T_OR_EQUAL
%token <Ast_php.info> T_PARENT
%token <Ast_php.info> T_PLUS_EQUAL
%token <Ast_php.info> T_PRINT
%token <Ast_php.info> T_PRIVATE
%token <Ast_php.info> T_PROTECTED
%token <Ast_php.info> T_PUBLIC
%token <Ast_php.info> T_REQUIRE
%token <Ast_php.info> T_REQUIRE_ONCE
%token <Ast_php.info> T_RESOURCE_XDEBUG
%token <Ast_php.info> T_RETURN
%token <Ast_php.info> T_SELF
%token <Ast_php.info> T_SHAPE
%token <Ast_php.info> T_SL
%token <Ast_php.info> T_SL_EQUAL
%token <Ast_php.info> T_SR
%token <Ast_php.info> T_SR_EQUAL
%token <Ast_php.info> T_START_HEREDOC
%token <Ast_php.info> T_STATIC
%token <Ast_php.info> T_STRING_CAST
%token <string * Ast_php.info> T_STRING_VARNAME
%token <Ast_php.info> T_SUPER
%token <Ast_php.info> T_SWITCH
%token <Ast_php.info> T_THROW
%token <Ast_php.info> T_TRAIT
%token <Ast_php.info> T_TRAIT_C
%token <Ast_php.info> T_TRY
%token <Ast_php.info> T_TYPE
%token <Ast_php.info> T_UNSET
%token <Ast_php.info> T_UNSET_CAST
%token <Ast_php.info> T_USE
%token <Ast_php.info> T_VAR
%token <string * Ast_php.info> T_VARIABLE
%token <Ast_php.info> T_WHILE
%token <Ast_php.info> T_XHP_ANY
%token <string * Ast_php.info> T_XHP_ATTR
%token <Ast_php.info> T_XHP_ATTRIBUTE
%token <Ast_php.info> T_XHP_CATEGORY
%token <Ast_php.info> T_XHP_CHILDREN
%token <Ast_php.xhp_tag option * Ast_php.info> T_XHP_CLOSE_TAG
%token <string list * Ast_php.info> T_XHP_COLONID_DEF
%token <Ast_php.info> T_XHP_GT
%token <Ast_php.xhp_tag * Ast_php.info> T_XHP_OPEN_TAG
%token <Ast_php.info> T_XHP_PCDATA
%token <string list * Ast_php.info> T_XHP_PERCENTID_DEF
%token <Ast_php.info> T_XHP_REQUIRED
%token <Ast_php.info> T_XHP_SLASH_GT
%token <string * Ast_php.info> T_XHP_TEXT
%token <Ast_php.info> T_XOR_EQUAL
%token <Ast_php.info> T_YIELD
%token <Ast_php.info> T__AT
%left T_TYPE
%left T_IDENT
%right T_ELLIPSIS
%nonassoc LOW_PRIORITY_RULE
%nonassoc T_YIELD
%nonassoc T_AWAIT
%left T_ARROW
%left T_EVAL T_INCLUDE T_INCLUDE_ONCE T_REQUIRE T_REQUIRE_ONCE
%right T_DOUBLE_ARROW
%left TCOMMA
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left TEQ T_AND_EQUAL T_CONCAT_EQUAL T_DIV_EQUAL T_MINUS_EQUAL T_MOD_EQUAL T_MUL_EQUAL T_OR_EQUAL T_PLUS_EQUAL T_SL_EQUAL T_SR_EQUAL T_XOR_EQUAL
%left TCOLON TQUESTION
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left TOR
%left TXOR
%left TAND
%nonassoc T_IS_EQUAL T_IS_IDENTICAL T_IS_NOT_EQUAL T_IS_NOT_IDENTICAL
%nonassoc TGREATER TSMALLER T_IS_GREATER_OR_EQUAL T_IS_SMALLER_OR_EQUAL
%left T_SL T_SR
%left TDOT TMINUS TPLUS
%left TDIV TMOD TMUL
%right TBANG
%nonassoc T_INSTANCEOF
%right TTILDE T_ARRAY_CAST T_BOOL_CAST T_DEC T_DOUBLE_CAST T_INC T_INT_CAST T_OBJECT_CAST T_STRING_CAST T_UNSET_CAST
%right T__AT
%right TOBRA
%nonassoc T_CLONE T_NEW
%left T_ELSEIF
%left T_ELSE
%left T_ENDIF
%left TCOLCOL
%left TDOLLAR
%left T_OBJECT_OPERATOR
%left T_XHP_PERCENTID_DEF
%type <Ast_php.toplevel list> main
%type <Ast_php.any> sgrep_spatch_pattern
%%

main:
  _1 = top_statement_list _2 = EOF
    {                             ( H.squash_stmt_list _1 @ [FinalDef _2] )}

top_statement:
  _1 = statement
    {                                        ( StmtList [_1] )}
| _1 = constant_declaration_statement
    {                                        ( ConstantDef _1 )}
| _1 = function_declaration_statement
    {                                  ( FuncDef _1 )}
| _1 = class_declaration_statement
    {                                ( ClassDef _1 )}
| _1 = type_declaration
    {                                        ( TypeDef _1 )}
| _1 = namespace_declaration
    {                                        ( _1 )}
| _1 = use_declaration
    {                                        ( _1 )}

sgrep_spatch_pattern:
  _1 = expr _2 = EOF
    {                 ( Expr _1 )}
| _1 = statement _2 = EOF
    {                 ( Stmt2 _1 )}
| _1 = function_declaration_statement
    {                                  ( Toplevel (FuncDef _1) )}
| _1 = TCOLON _2 = type_php
    {                   ( Hint2 _2 )}

statement:
  _1 = expr _2 = TSEMICOLON
    {                                ( ExprStmt(_1,_2) )}
| _1 = TSEMICOLON
    {                                          ( EmptyStmt(_1) )}
| _1 = TOBRACE _2 = inner_statement_list _3 = TCBRACE
    {                                          ( Block(_1,_2,_3) )}
| _1 = T_IF _2 = TOPAR _3 = expr _4 = TCPAR _5 = statement _6 = elseif_list _7 = else_single
    {     ( If(_1,(_2,_3,_4),_5,_6,_7) )}
| _1 = T_IF _2 = TOPAR _3 = expr _4 = TCPAR _5 = TCOLON _6 = inner_statement_list _7 = new_elseif_list _8 = new_else_single _9 = T_ENDIF _10 = TSEMICOLON
    {     ( IfColon(_1,(_2,_3,_4),_5,_6,_7,_8,_9,_10)  )}
| _1 = T_WHILE _2 = TOPAR _3 = expr _4 = TCPAR _5 = while_statement
    {     ( While(_1,(_2,_3,_4),_5) )}
| _1 = T_DO _2 = statement _3 = T_WHILE _4 = TOPAR _5 = expr _6 = TCPAR _7 = TSEMICOLON
    {     ( Do(_1,_2,_3,(_4,_5,_6),_7) )}
| _1 = T_FOR _2 = TOPAR _3 = for_expr _4 = TSEMICOLON _5 = for_expr _6 = TSEMICOLON _7 = for_expr _8 = TCPAR _9 = for_statement
    {     ( For(_1,_2,_3,_4,_5,_6,_7,_8,_9) )}
| _1 = T_SWITCH _2 = TOPAR _3 = expr _4 = TCPAR _5 = switch_case_list
    {     ( Switch(_1,(_2,_3,_4),_5) )}
| _1 = T_FOREACH _2 = TOPAR _3 = expr _4 = T_AS _5 = foreach_pattern _6 = TCPAR _7 = foreach_statement
    {     ( Foreach(_1,_2,_3,None, _4,_5,_6,_7) )}
| _1 = T_FOREACH _2 = TOPAR _3 = expr _4 = T_AWAIT _5 = T_AS _6 = foreach_pattern _7 = TCPAR _8 = foreach_statement
    {     ( Foreach(_1,_2,_3, Some _4, _5,_6,_7, _8) )}
| _1 = T_BREAK _2 = TSEMICOLON
    {                                ( Break(_1,None,_2) )}
| _1 = T_BREAK _2 = expr _3 = TSEMICOLON
    {                           ( Break(_1,Some _2, _3) )}
| _1 = T_CONTINUE _2 = TSEMICOLON
    {                              ( Continue(_1,None,_2) )}
| _1 = T_CONTINUE _2 = expr _3 = TSEMICOLON
    {                              ( Continue(_1,Some _2, _3) )}
| _1 = T_RETURN _2 = TSEMICOLON
    {                            ( Return (_1,None, _2) )}
| _1 = T_RETURN _2 = expr _3 = TSEMICOLON
    {                             ( Return (_1,Some (_2), _3))}
| _1 = T_TRY _2 = TOBRACE _3 = inner_statement_list _4 = TCBRACE _5 = T_CATCH _6 = TOPAR _7 = class_name _8 = T_VARIABLE _9 = TCPAR _10 = TOBRACE _11 = inner_statement_list _12 = TCBRACE _13 = additional_catches _14 = optional_finally_clause
    {     ( let try_block = (_2,_3,_4) in
       let catch_block = (_10, _11, _12) in
       let catch = (_5, (_6, (_7, DName _8), _9), catch_block) in
       Try(_1, try_block, [catch] @ _13, _14)
     )}
| _1 = T_TRY _2 = TOBRACE _3 = inner_statement_list _4 = TCBRACE _5 = finally_clause
    {     ( let try_block = (_2,_3,_4) in
       Try(_1, try_block, [], [_5])
     )}
| _1 = T_THROW _2 = expr _3 = TSEMICOLON
    {                           ( Throw(_1,_2,_3) )}
| _1 = T_ECHO _2 = echo_expr_list _3 = TSEMICOLON
    {                                        ( Echo(_1,_2,_3) )}
| _1 = T_INLINE_HTML
    {                   ( InlineHtml(_1) )}
| _1 = T_OPEN_TAG_WITH_ECHO _2 = expr _3 = T_CLOSE_TAG_OF_ECHO
    {                                                 (
     (* ugly: the 2 tokens will have a wrong string *)
     Echo (_1, [Left _2], _3)
   )}
| _1 = T_OPEN_TAG_WITH_ECHO _2 = expr _3 = TSEMICOLON _4 = T_CLOSE_TAG_OF_ECHO
    {                                                            (
     Echo (_1, [Left _2], _4)
   )}
| _1 = T_GLOBAL _2 = global_var_list _3 = TSEMICOLON
    {                                       ( Globals(_1,_2,_3) )}
| _1 = T_STATIC _2 = static_var_list _3 = TSEMICOLON
    {                                       ( StaticVars(_1,_2,_3) )}
| _1 = T_UNSET _2 = TOPAR _3 = unset_variables _4 = TCPAR _5 = TSEMICOLON
    {                                                  ( Unset(_1,(_2,_3,_4),_5) )}
| _1 = T_USE _2 = use_filename _3 = TSEMICOLON
    {                                    ( Use(_1,_2,_3) )}
| _1 = T_DECLARE _2 = TOPAR _3 = declare_list _4 = TCPAR _5 = declare_statement
    {     ( Declare(_1,(_2,_3,_4),_5) )}

inner_statement:
  _1 = statement
    {                                        ( _1 )}
| _1 = function_declaration_statement
    {                                  ( FuncDefNested _1 )}
| _1 = class_declaration_statement
    {                                ( ClassDefNested _1 )}

for_expr:
  
    {                     ( [] )}
| _1 = non_empty_for_expr
    {                      ( _1 )}

foreach_variable:
  _1 = expr
    {              ( None, _1 )}
| _1 = TAND _2 = expr
    {              ( Some _1, _2 )}

foreach_pattern:
  _1 = foreach_variable
    {      ( ForeachVar _1 )}
| _1 = foreach_variable _2 = T_ARROW _3 = foreach_pattern
    {      ( ForeachArrow(ForeachVar _1,_2,_3) )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR
    {     ( ForeachList(_1,(_2,_3,_4)) )}

switch_case_list:
  _1 = TOBRACE _2 = case_list _3 = TCBRACE
    {     ( CaseList(_1,None,_2,_3) )}
| _1 = TOBRACE _2 = TSEMICOLON _3 = case_list _4 = TCBRACE
    {     ( CaseList(_1, Some _2, _3, _4) )}
| _1 = TCOLON _2 = case_list _3 = T_ENDSWITCH _4 = TSEMICOLON
    {     ( CaseColonList(_1,None,_2, _3, _4) )}
| _1 = TCOLON _2 = TSEMICOLON _3 = case_list _4 = T_ENDSWITCH _5 = TSEMICOLON
    {     ( CaseColonList(_1, Some _2, _3, _4, _5) )}
| _1 = T_XHP_COLONID_DEF
    {                     ( H.failwith_xhp_ambiguity_colon (snd _1) )}

case_list:
  _1 = case_list_rev
    {                         ( List.rev _1 )}

case_list_rev:
  
    {                 ( [] )}
| _1 = case_list_rev _2 = T_CASE _3 = expr _4 = case_separator _5 = inner_statement_list
    {     ( Case(_2,_3,_4,_5)::_1   )}
| _1 = case_list_rev _2 = T_DEFAULT _3 = case_separator _4 = inner_statement_list
    {     ( Default(_2,_3,_4)::_1 )}

case_separator:
  _1 = TCOLON
    {              ( _1 )}
| _1 = TSEMICOLON
    {              ( _1 )}
| _1 = T_XHP_COLONID_DEF
    {                     ( H.failwith_xhp_ambiguity_colon (snd _1) )}

while_statement:
  _1 = statement
    {                                                     ( SingleStmt _1 )}
| _1 = TCOLON _2 = inner_statement_list _3 = T_ENDWHILE _4 = TSEMICOLON
    {                                                     ( ColonStmt(_1,_2,_3,_4) )}

for_statement:
  _1 = statement
    {                                                   ( SingleStmt _1 )}
| _1 = TCOLON _2 = inner_statement_list _3 = T_ENDFOR _4 = TSEMICOLON
    {                                                   ( ColonStmt(_1,_2,_3,_4) )}

foreach_statement:
  _1 = statement
    {                                                       ( SingleStmt _1 )}
| _1 = TCOLON _2 = inner_statement_list _3 = T_ENDFOREACH _4 = TSEMICOLON
    {                                                       ( ColonStmt(_1,_2,_3,_4))}

declare_statement:
  _1 = statement
    {                                                       ( SingleStmt _1 )}
| _1 = TCOLON _2 = inner_statement_list _3 = T_ENDDECLARE _4 = TSEMICOLON
    {                                                       ( ColonStmt(_1,_2,_3,_4))}

elseif_list:
  
    {                 ( [] )}
| _1 = elseif_list _2 = T_ELSEIF _3 = TOPAR _4 = expr _5 = TCPAR _6 = statement
    {                                                    ( _1 @ [_2,(_3,_4,_5),_6])}

new_elseif_list:
  
    {                 ( [] )}
| _1 = new_elseif_list _2 = T_ELSEIF _3 = TOPAR _4 = expr _5 = TCPAR _6 = TCOLON _7 = inner_statement_list
    {     ( _1 @ [_2,(_3,_4,_5),_6,_7] )}

else_single:
  _1 = T_ELSE _2 = statement
    {                                           ( Some(_1,_2) )}
|  %prec LOW_PRIORITY_RULE
    {                                           ( None )}

new_else_single:
  
    {                                      ( None )}
| _1 = T_ELSE _2 = TCOLON _3 = inner_statement_list
    {                                      ( Some(_1,_2,_3) )}

additional_catch:
  _1 = T_CATCH _2 = TOPAR _3 = class_name _4 = T_VARIABLE _5 = TCPAR _6 = TOBRACE _7 = inner_statement_list _8 = TCBRACE
    {     ( let catch_block = (_6, _7, _8) in
       let catch = (_1, (_2, (_3, DName _4), _5), catch_block) in
       catch
     )}

finally_clause:
  _1 = T_FINALLY _2 = TOBRACE _3 = inner_statement_list _4 = TCBRACE
    {     ( (_1, (_2, _3, _4)) )}

declare:
  _1 = ident _2 = TEQ _3 = static_scalar
    {                                   ( Name _1, (_2, _3) )}

global_var:
  _1 = T_VARIABLE
    {                ( GlobalVar (DName _1) )}
| _1 = TDOLLAR _2 = expr
    {                   ( GlobalDollar (_1, _2) )}
| _1 = TDOLLAR _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                                ( GlobalDollarExpr (_1, (_2, _3, _4)) )}

static_var:
  _1 = T_VARIABLE
    {                                ( (DName _1, None) )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {                                ( (DName _1, Some (_2, _3)) )}

unset_variable:
  _1 = expr
    {                     ( _1 )}

use_filename:
  _1 = T_CONSTANT_ENCAPSED_STRING
    {                                     ( UseDirect _1 )}
| _1 = TOPAR _2 = T_CONSTANT_ENCAPSED_STRING _3 = TCPAR
    {                                          ( UseParen (_1, _2, _3) )}

constant_declaration_statement:
  _1 = T_CONST _2 = ident _3 = TEQ _4 = static_scalar _5 = TSEMICOLON
    {   ( { cst_toks = (_1, _3, _5); cst_name = Name _2; cst_val = _4;
       cst_type = None} )}
| _1 = T_CONST _2 = type_php _3 = ident _4 = TEQ _5 = static_scalar _6 = TSEMICOLON
    {   ( { cst_toks = (_1, _4, _6); cst_name = Name _3; cst_val = _5;
       cst_type = Some _2 } )}

function_declaration_statement:
  _1 = unticked_function_declaration_statement
    {                                                      ( _1 )}
| _1 = attributes _2 = unticked_function_declaration_statement
    {     ( { _2 with f_attrs = Some _1 } )}

unticked_function_declaration_statement:
  _1 = async_opt _2 = T_FUNCTION _3 = is_reference _4 = ident _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = return_type_opt _10 = function_body
    {   ( { f_tok = _2; f_ref = _3; f_name = Name _4; f_params = (_6, _7, _8);
       f_tparams = _5;
       f_return_type = _9; f_body = _10;
       f_attrs = None;
       f_type = FunctionRegular; f_modifiers = _1;
    } )}

function_body:
  _1 = TOBRACE _2 = inner_statement_list _3 = TCBRACE
    {                                            ( (_1, _2, _3)  )}
| _1 = TSEMICOLON
    {              ( (* ugly: *) (Ast.fakeInfo"", [], _1) )}

async_opt:
  
    {                 ( [] )}
| _1 = T_ASYNC
    {           ( [Async,(_1)] )}

parameter_list:
  
    {                              ( [] )}
| _1 = non_empty_parameter_list
    {                              ( _1 )}
| _1 = non_empty_parameter_list _2 = TCOMMA
    {                                    ( _1 @ [Right3 _2] )}

parameter_or_dots:
  _1 = parameter
    {             ( Left3 _1 )}
| _1 = T_ELLIPSIS
    {              ( Middle3 _1 )}
| _1 = T_ELLIPSIS _2 = T_VARIABLE
    {     ( Left3 (H.mk_param _2) (* todo: with is_variadic = true *) )}

parameter:
  _1 = attributes_opt _2 = ctor_modifier_opt _3 = at_opt _4 = type_php_opt _5 = parameter_bis
    {      ( { _5 with p_modifier = _2; p_attrs = _1; p_type = _4; p_soft_type= _3;})}

parameter_bis:
  _1 = T_VARIABLE
    {     ( H.mk_param _1 )}
| _1 = TAND _2 = T_VARIABLE
    {     ( let p = H.mk_param _2 in {p with p_ref=Some _1} )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {     ( let p = H.mk_param _1 in {p with p_default=Some(_2,_3)} )}
| _1 = TAND _2 = T_VARIABLE _3 = TEQ _4 = static_scalar
    {     ( let p = H.mk_param _2 in {p with p_ref=Some _1; p_default=Some(_3,_4)})}

ctor_modifier:
  _1 = T_PUBLIC
    {               ( Public,(_1) )}
| _1 = T_PROTECTED
    {                                             ( Protected,(_1) )}
| _1 = T_PRIVATE
    {               ( Private,(_1) )}

is_reference:
  
    {                  ( None )}
| _1 = TAND
    {           ( Some _1 )}

lexical_vars:
  
    {                  ( None )}
| _1 = T_USE _2 = TOPAR _3 = non_empty_lexical_var_list _4 = TCPAR
    {                                                (
     Some (_1, (_2, (_3 +> List.map (function
     | Right info -> Right info
     | Left (a,b) -> Left (LexicalVar (a,b)))), _4))
   )}

non_empty_lexical_var_list:
  _1 = non_empty_lexical_var_list_bis
    {                                  ( _1 )}
| _1 = non_empty_lexical_var_list_bis _2 = TCOMMA
    {                                         ( _1 @ [Right _2] )}

non_empty_lexical_var_list_bis:
  _1 = lexical_var
    {     ( [Left _1] )}
| _1 = non_empty_lexical_var_list_bis _2 = TCOMMA _3 = lexical_var
    {     ( _1 @ [Right _2; Left _3] )}

lexical_var:
  _1 = T_VARIABLE
    {                    ( (None, DName _1) )}
| _1 = TAND _2 = T_VARIABLE
    {                    ( (Some _1, DName _2) )}

class_declaration_statement:
  _1 = unticked_class_declaration_statement
    {     ( _1 )}
| _1 = attributes _2 = unticked_class_declaration_statement
    {     ( { _2 with c_attrs = Some _1 } )}

unticked_class_declaration_statement:
  _1 = class_entry_type _2 = ident_class_name _3 = type_params_opt _4 = extends_from _5 = implements_list _6 = TOBRACE _7 = class_statement_list _8 = TCBRACE
    {     ( { c_type = _1; c_name = _2; c_extends = _4; c_tparams = _3;
         c_implements = _5; c_body = _6, _7, _8;
         c_attrs = None;
         c_enum_type = None;
       }
     )}
| _1 = T_INTERFACE _2 = ident_class_name _3 = type_params_opt _4 = interface_extends_list _5 = TOBRACE _6 = class_statement_list _7 = TCBRACE
    {     ( { c_type = Interface _1; c_name = _2; c_extends = None; c_tparams = _3;
         (* we use c_implements for interface extension because
          * it can be a list. ugly?
          *)
         c_implements = _4; c_body = _5, _6, _7;
         c_attrs = None;
         c_enum_type = None;
     } )}
| _1 = T_TRAIT _2 = ident_class_name _3 = type_params_opt _4 = implements_list _5 = TOBRACE _6 = class_statement_list _7 = TCBRACE
    {     ( { c_type = Trait _1; c_name = _2; c_extends = None; c_tparams = _3;
         c_implements = _4; c_body = (_5, _6, _7);
         c_attrs = None;
         c_enum_type = None;
       }
     )}
| _1 = T_ENUM _2 = ident_class_name _3 = TCOLON _4 = type_php _5 = type_constr_opt _6 = TOBRACE _7 = enum_statement_list _8 = TCBRACE
    {     ( { c_type = Enum _1; c_name = _2; c_extends = None; c_tparams = None;
         c_implements = None; c_body = (_6, _7, _8);
         c_attrs = None;
         c_enum_type = Some { e_tok = _3; e_base = _4; e_constraint = _5; }
       }
     )}

class_entry_type:
  _1 = T_CLASS
    {                   ( ClassRegular _1 )}
| _1 = T_ABSTRACT _2 = T_FINAL _3 = T_CLASS
    {                              ( ClassAbstractFinal (_1, _2, _3) )}
| _1 = T_FINAL _2 = T_ABSTRACT _3 = T_CLASS
    {                              ( ClassAbstractFinal (_1, _2, _3) )}
| _1 = T_ABSTRACT _2 = T_CLASS
    {                      ( ClassAbstract (_1, _2) )}
| _1 = T_FINAL _2 = T_CLASS
    {                      ( ClassFinal (_1, _2) )}

extends_from:
  
    {                          ( None )}
| _1 = T_EXTENDS _2 = class_name_no_array
    {                                 ( Some (_1, _2)  )}

interface_extends_list:
  
    {                            ( None )}
| _1 = T_EXTENDS _2 = class_name_list
    {                             ( Some(_1,_2) )}

implements_list:
  
    {                               ( None )}
| _1 = T_IMPLEMENTS _2 = class_name_list
    {                                ( Some(_1, _2) )}

class_statement:
  _1 = T_ABSTRACT _2 = T_CONST _3 = ident _4 = TSEMICOLON
    {     ( let const = (Name _3, None) in
       let const_list = [Left const] in
       ClassConstants(Some _1, _2, None, const_list, _4) )}
| _1 = T_ABSTRACT _2 = T_CONST _3 = type_php _4 = ident _5 = TSEMICOLON
    {     ( let const = (Name _4, None) in
       let const_list = [Left const] in
       ClassConstants(Some _1, _2, Some _3, const_list, _5) )}
| _1 = T_ABSTRACT _2 = T_CONST _3 = T_TYPE _4 = T_IDENT _5 = T_AS _6 = type_php _7 = TSEMICOLON
    {     ( ClassType (* TODO (t6384084) add some fields here *) {
         t_tok = _3;
         t_name = Name _4;
         t_tparams = None;
         t_tconstraint = Some(_5, _6);
         t_tokeq = _5; (* doesn't exist here *)
         t_kind = ClassConstType None;
         t_sc = _7; }
     )}
| _1 = T_ABSTRACT _2 = T_CONST _3 = T_TYPE _4 = T_IDENT _5 = TSEMICOLON
    {     ( ClassType (* TODO (t6384084) add some fields here *) {
         t_tok = _3;
         t_name = Name _4;
         t_tparams = None;
         t_tconstraint = None;
         t_tokeq = _5; (* doesn't exist here *)
         t_kind = ClassConstType None;
         t_sc = _5; }
     )}
| _1 = T_CONST _2 = T_TYPE _3 = T_IDENT _4 = type_constr_opt _5 = TEQ _6 = type_php_or_shape _7 = TSEMICOLON
    {     ( ClassType (* TODO (t6384084) add some fields here *) {
         t_tok = _2;
         t_name = Name _3;
         t_tparams = None;
         t_tconstraint = _4;
         t_tokeq = _5;
         t_kind = ClassConstType (Some _6);
         t_sc = _7; }
     )}
| _1 = T_CONST _2 = class_constants_declaration _3 = TSEMICOLON
    {     ( ClassConstants(None, _1, None, _2, _3) )}
| _1 = T_CONST _2 = type_php _3 = class_constants_declaration _4 = TSEMICOLON
    {     ( ClassConstants(None, _1, Some _2, _3, _4) )}
| _1 = variable_modifiers _2 = class_variable_declaration _3 = TSEMICOLON
    {     ( ClassVariables(_1, None, _2, _3) )}
| _1 = variable_modifiers _2 = type_php _3 = class_variable_declaration _4 = TSEMICOLON
    {     ( ClassVariables(_1, Some _2, _3, _4)  )}
| _1 = method_declaration
    {                                 ( Method _1 )}
| _1 = attributes _2 = method_declaration
    {                                 ( Method { _2 with f_attrs = Some _1 } )}
| _1 = T_XHP_ATTRIBUTE _2 = xhp_attribute_decls _3 = TSEMICOLON
    {     ( XhpDecl (XhpAttributesDecl (_1, _2, _3)) )}
| _1 = T_XHP_CHILDREN _2 = xhp_children_decl _3 = TSEMICOLON
    {     ( XhpDecl (XhpChildrenDecl (_1, _2, _3)) )}
| _1 = T_XHP_CATEGORY _2 = xhp_category_list _3 = TSEMICOLON
    {     ( XhpDecl (XhpCategoriesDecl (_1, _2, _3)) )}
| _1 = T_USE _2 = class_name_list _3 = TSEMICOLON
    {     ( UseTrait (_1, _2, Left _3) )}
| _1 = T_USE _2 = class_name_list _3 = TOBRACE _4 = trait_rules _5 = TCBRACE
    {     ( UseTrait (_1, _2, Right (_3, _4, _5)) )}
| _1 = T_REQUIRE _2 = trait_constraint_kind _3 = type_php _4 = TSEMICOLON
    {     ( TraitConstraint (_1, _2, _3, _4) )}

enum_statement:
  _1 = class_constant_declaration _2 = TSEMICOLON
    {     ( ClassConstants(None, _2, None, [Left _1], _2) )}

method_declaration:
  _1 = method_modifiers _2 = T_FUNCTION _3 = is_reference _4 = ident_method_name _5 = type_params_opt _6 = TOPAR _7 = parameter_list _8 = TCPAR _9 = return_type_opt _10 = method_body
    {     ( let body, function_type = _10 in
       ({ f_tok = _2; f_ref = _3; f_name = Name _4; f_tparams = _5;
          f_params = (_6, _7, _8); f_return_type = _9;
          f_body = body; f_type = function_type; f_modifiers = _1;
          f_attrs = None;
        })
     )}

class_constant_declaration:
  _1 = ident _2 = TEQ _3 = static_scalar
    {                                                    ( ((Name _1), Some (_2, _3)) )}

variable_modifiers:
  _1 = T_VAR
    {            ( NoModifiers _1 )}
| _1 = non_empty_member_modifiers
    {                               ( VModifiers _1 )}

class_variable:
  _1 = T_VARIABLE
    {                ( (DName _1, None) )}
| _1 = T_VARIABLE _2 = TEQ _3 = static_scalar
    {                                ( (DName _1, Some (_2, _3)) )}

member_modifier:
  _1 = T_PUBLIC
    {               ( Public,(_1) )}
| _1 = T_PROTECTED
    {                                             ( Protected,(_1) )}
| _1 = T_PRIVATE
    {               ( Private,(_1) )}
| _1 = T_STATIC
    {               ( Static,(_1) )}
| _1 = T_ABSTRACT
    {              ( Abstract,(_1) )}
| _1 = T_FINAL
    {                                         ( Final,(_1) )}
| _1 = T_ASYNC
    {           ( Async,(_1) )}

method_body:
  _1 = TOBRACE _2 = inner_statement_list _3 = TCBRACE
    {                                        ( (_1, _2, _3), MethodRegular )}
| _1 = TSEMICOLON
    {              ( (* ugly: *) (Ast.fakeInfo"", [], _1), MethodAbstract )}

xhp_attribute_decl:
  _1 = T_XHP_COLONID_DEF
    {     ( XhpAttrInherit _1 )}
| _1 = xhp_attribute_decl_type _2 = xhp_attr_name _3 = xhp_attribute_default _4 = xhp_attribute_is_required
    {     ( XhpAttrDecl (_1, ((PI.str_of_info _2, _2)), _3, _4) )}

xhp_attribute_decl_type:
  _1 = T_ENUM _2 = TOBRACE _3 = xhp_enum_list _4 = TCBRACE
    {     ( XhpAttrEnum (_1, (_2, _3, _4)) )}
| _1 = T_VAR
    {                ( XhpAttrVar _1 )}
| _1 = type_php
    {            ( XhpAttrType _1 )}

xhp_attribute_default:
  
    {                     ( None )}
| _1 = TEQ _2 = static_scalar
    {                     ( Some (_1, _2) )}

xhp_attribute_is_required:
  
    {                  ( None )}
| _1 = T_XHP_REQUIRED
    {                  ( Some _1 )}

xhp_enum:
  _1 = constant
    {            ( _1 )}

xhp_attr_name:
  _1 = ident_xhp_attr_name_atom
    {                            ( _1 )}
| _1 = xhp_attr_name _2 = TMINUS _3 = ident_xhp_attr_name_atom
    {     ( let s = PI.str_of_info _1 ^  PI.str_of_info _2 ^ PI.str_of_info _3 in
       PI.rewrap_str s _1
     )}
| _1 = xhp_attr_name _2 = TCOLON _3 = ident_xhp_attr_name_atom
    {     ( let s = PI.str_of_info _1 ^  PI.str_of_info _2 ^ PI.str_of_info _3 in
       PI.rewrap_str s _1
     )}

xhp_children_decl:
  _1 = T_XHP_ANY
    {             ( XhpChildAny _1 )}
| _1 = T_EMPTY
    {             ( XhpChildEmpty _1 )}
| _1 = xhp_children_paren_expr
    {                           ( _1 )}

xhp_children_paren_expr:
  _1 = TOPAR _2 = xhp_children_decl_expr _3 = TCPAR
    {     ( XhpChildParen (_1, _2, _3) )}
| _1 = TOPAR _2 = xhp_children_decl_expr _3 = TCPAR _4 = TMUL
    {     ( XhpChildMul (XhpChildParen (_1, _2, _3), _4) )}
| _1 = TOPAR _2 = xhp_children_decl_expr _3 = TCPAR _4 = TQUESTION
    {     ( XhpChildOption (XhpChildParen (_1, _2, _3), _4) )}
| _1 = TOPAR _2 = xhp_children_decl_expr _3 = TCPAR _4 = TPLUS
    {     ( XhpChildPlus (XhpChildParen (_1, _2, _3), _4) )}

xhp_children_decl_expr:
  _1 = xhp_children_paren_expr
    {                           ( _1 )}
| _1 = xhp_children_decl_tag
    {                         ( _1 )}
| _1 = xhp_children_decl_tag _2 = TMUL
    {                                   ( XhpChildMul (_1, _2)  )}
| _1 = xhp_children_decl_tag _2 = TQUESTION
    {                                   ( XhpChildOption (_1, _2) )}
| _1 = xhp_children_decl_tag _2 = TPLUS
    {                                   ( XhpChildPlus (_1, _2) )}
| _1 = xhp_children_decl_expr _2 = TCOMMA _3 = xhp_children_decl_expr
    {     ( XhpChildSequence (_1, _2, _3) )}
| _1 = xhp_children_decl_expr _2 = TOR _3 = xhp_children_decl_expr
    {     ( XhpChildAlternative (_1, _2, _3) )}

xhp_children_decl_tag:
  _1 = T_XHP_ANY
    {                       ( XhpChildAny (_1) )}
| _1 = T_XHP_PCDATA
    {                       ( XhpChildPcdata (_1) )}
| _1 = T_XHP_COLONID_DEF
    {                       ( XhpChild _1 )}
| _1 = T_XHP_PERCENTID_DEF
    {                       ( XhpChildCategory _1 )}

xhp_category:
  _1 = T_XHP_PERCENTID_DEF
    {                       ( _1 )}

trait_rule:
  _1 = trait_precedence_rule
    {                          ( _1 )}
| _1 = trait_alias_rule
    {                          ( _1 )}

trait_precedence_rule:
  _1 = qualified_name_for_traits _2 = TCOLCOL _3 = T_IDENT _4 = T_INSTEADOF _5 = class_name_list _6 = TSEMICOLON
    {   ( InsteadOf (_1, _2, Name _3, _4, _5, _6) )}

trait_alias_rule:
  _1 = trait_alias_rule_method _2 = T_AS _3 = method_modifiers _4 = T_IDENT _5 = TSEMICOLON
    {   ( As (_1, _2, _3, Some (Name _4), _5) )}
| _1 = trait_alias_rule_method _2 = T_AS _3 = non_empty_member_modifiers _4 = TSEMICOLON
    {   ( As (_1, _2, _3, None, _4) )}

trait_alias_rule_method:
  _1 = qualified_name_for_traits _2 = TCOLCOL _3 = T_IDENT
    {                                             ( Right (_1, _2, Name _3) )}
| _1 = T_IDENT
    {           ( Left (Name _1) )}

trait_constraint_kind:
  _1 = T_EXTENDS
    {                ( MustExtend, _1 )}
| _1 = T_IMPLEMENTS
    {                ( MustImplement, _1 )}

type_declaration:
  _1 = T_TYPE _2 = ident _3 = type_params_opt _4 = type_constr_opt _5 = TEQ _6 = type_php_or_shape _7 = TSEMICOLON
    {     ( { t_tok = _1; t_name = Name _2; t_tparams = _3; t_tconstraint = _4;
         t_tokeq = _5; t_kind = Alias _6; t_sc = _7; }
     )}
| _1 = T_NEWTYPE _2 = ident _3 = type_params_opt _4 = type_constr_opt _5 = TEQ _6 = type_php_or_shape _7 = TSEMICOLON
    {     ( { t_tok = _1; t_name = Name _2; t_tparams = _3; t_tconstraint = _4;
         t_tokeq = _5; t_kind = Newtype _6; t_sc = _7; }
     )}

type_php_or_shape:
  _1 = type_php
    {            ( _1 )}
| _1 = T_SHAPE _2 = TOPAR _3 = shape_field_list _4 = TCPAR
    {                                        ( HintShape (_1, (_2, _3, _4)) )}

shape_field:
  _1 = expr _2 = T_ARROW _3 = type_php
    {                                   ( _1, _2, _3 )}

type_constr_opt:
  _1 = T_AS _2 = type_php
    {                  ( Some (_1, _2) )}
| 
    {                  ( None )}

type_params_opt:
  
    {                                       ( None )}
| _1 = TSMALLER _2 = type_params_list _3 = TGREATER
    {                                       ( Some (_1, _2, _3) )}

type_params_list:
  _1 = type_param
    {                                       ( [Left _1] )}
| _1 = type_param _2 = TCOMMA _3 = type_params_list
    {                                       ( [Left _1; Right _2] @ _3 )}

type_param:
  _1 = variance_opt _2 = ident
    {                                       ( TParam (Name _2) )}
| _1 = variance_opt _2 = ident _3 = T_AS _4 = TQUESTION _5 = class_name
    {                                                 ( TParamConstraint (Name _2, _3, HintQuestion (_4, _5)) )}
| _1 = variance_opt _2 = ident _3 = T_AS _4 = class_name
    {                                       ( TParamConstraint (Name _2, _3, _4) )}
| _1 = variance_opt _2 = ident _3 = T_SUPER _4 = TQUESTION _5 = class_name
    {                                                    ( TParamConstraint (Name _2, _3, HintQuestion (_4, _5)) )}
| _1 = variance_opt _2 = ident _3 = T_SUPER _4 = class_name
    {                                          ( TParamConstraint (Name _2, _3, _4) )}

variance_opt:
  
    {                    (None)}
| _1 = TMINUS
    {          ( Some _1 )}
| _1 = TPLUS
    {          ( Some _1 )}

type_php:
  _1 = primary_type_php
    {                    ( _1 )}
| _1 = type_php _2 = TCOLCOL _3 = primary_type_php
    {                                     ( HintTypeConst (_1, _2, _3) )}

primary_type_php:
  _1 = class_name
    {              ( _1 )}
| _1 = T_SELF
    {              ( Hint (Self _1, None) )}
| _1 = T_PARENT
    {              ( Hint (Parent _1, None) )}
| _1 = TQUESTION _2 = type_php
    {     ( HintQuestion (_1, _2)  )}
| _1 = TOPAR _2 = non_empty_type_php_list _3 = TCPAR
    {     ( HintTuple (_1, _2, _3) )}
| _1 = TOPAR _2 = T_FUNCTION _3 = TOPAR _4 = type_php_or_dots_list _5 = TCPAR _6 = return_type _7 = TCPAR
    {     ( HintCallback (_1, (_2, (_3, _4, _5), Some _6), _7))}

type_php_or_dots_list:
  
    {                                     ( [] )}
| _1 = non_empty_type_php_or_dots_list
    {                                     ( _1 )}
| _1 = non_empty_type_php_or_dots_list _2 = TCOMMA
    {                                          ( _1 @ [Right3 _2] )}

type_php_or_dots:
  _1 = type_php
    {            ( Left3 _1 )}
| _1 = T_ELLIPSIS
    {                 ( Middle3 _1 )}

type_arguments:
  
    {                              ( None )}
| _1 = TSMALLER _2 = type_arg_list _3 = TGREATER
    {                                    ( Some (_1, _2, _3) )}

type_arg_list:
  _1 = type_php
    {      ( [Left _1])}
| _1 = type_php _2 = TCOMMA _3 = type_arg_list
    {      ( (Left _1)::(Right _2):: _3 )}

return_type:
  _1 = TCOLON _2 = at_opt _3 = type_php
    {                                                    ( _1, _2, _3 )}

attributes:
  _1 = T_SL _2 = attribute_list _3 = T_SR
    {                                     ( (_1, _2, _3) )}

attribute:
  _1 = ident
    {     ( Attribute _1 )}
| _1 = ident _2 = TOPAR _3 = attribute_argument_list _4 = TCPAR
    {     ( AttributeWithArgs (_1, (_2, _3, _4)) )}

attribute_argument:
  _1 = static_scalar
    {                                  ( _1 )}

expr:
  _1 = simple_expr
    {               ( _1 )}
| _1 = simple_expr _2 = TEQ _3 = expr
    {                        ( Assign(_1,_2, _3) )}
| _1 = simple_expr _2 = TEQ _3 = TAND _4 = expr
    {                               ( AssignRef(_1,_2,_3, _4) )}
| _1 = simple_expr _2 = T_PLUS_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Plus,_2),_3) )}
| _1 = simple_expr _2 = T_MINUS_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Minus,_2),_3) )}
| _1 = simple_expr _2 = T_MUL_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Mul,_2),_3) )}
| _1 = simple_expr _2 = T_DIV_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Div,_2),_3) )}
| _1 = simple_expr _2 = T_MOD_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Mod,_2),_3) )}
| _1 = simple_expr _2 = T_AND_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith And,_2),_3) )}
| _1 = simple_expr _2 = T_OR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Or,_2),_3) )}
| _1 = simple_expr _2 = T_XOR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith Xor,_2),_3) )}
| _1 = simple_expr _2 = T_SL_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith DecLeft,_2),_3) )}
| _1 = simple_expr _2 = T_SR_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignOpArith DecRight,_2),_3) )}
| _1 = simple_expr _2 = T_CONCAT_EQUAL _3 = expr
    {                                   ( AssignOp(_1,(AssignConcat,_2),_3) )}
| _1 = expr _2 = T_INC
    {              ( Postfix(_1, (Inc, _2)) )}
| _1 = expr _2 = T_DEC
    {              ( Postfix(_1, (Dec, _2)) )}
| _1 = T_INC _2 = expr
    {              ( Infix((Inc, _1), _2) )}
| _1 = T_DEC _2 = expr
    {              ( Infix((Dec, _1), _2) )}
| _1 = expr _2 = T_BOOLEAN_OR _3 = expr
    {                            ( Binary(_1,(Logical OrBool ,_2),_3) )}
| _1 = expr _2 = T_BOOLEAN_AND _3 = expr
    {                            ( Binary(_1,(Logical AndBool,_2),_3) )}
| _1 = expr _2 = T_LOGICAL_OR _3 = expr
    {                            ( Binary(_1,(Logical OrLog,  _2),_3) )}
| _1 = expr _2 = T_LOGICAL_AND _3 = expr
    {                            ( Binary(_1,(Logical AndLog, _2),_3) )}
| _1 = expr _2 = T_LOGICAL_XOR _3 = expr
    {                            ( Binary(_1,(Logical XorLog, _2),_3) )}
| _1 = expr _2 = TPLUS _3 = expr
    {                    ( Binary(_1,(Arith Plus ,_2),_3) )}
| _1 = expr _2 = TMINUS _3 = expr
    {                     ( Binary(_1,(Arith Minus,_2),_3) )}
| _1 = expr _2 = TMUL _3 = expr
    {                  ( Binary(_1,(Arith Mul,_2),_3) )}
| _1 = expr _2 = TDIV _3 = expr
    {                  ( Binary(_1,(Arith Div,_2),_3) )}
| _1 = expr _2 = TMOD _3 = expr
    {                   ( Binary(_1,(Arith Mod,_2),_3) )}
| _1 = expr _2 = T_XHP_PERCENTID_DEF
    {                             ( H.failwith_xhp_ambiguity_percent (snd _2) )}
| _1 = expr _2 = TAND _3 = expr
    {                  ( Binary(_1,(Arith And,_2),_3) )}
| _1 = expr _2 = TOR _3 = expr
    {                 ( Binary(_1,(Arith Or,_2),_3) )}
| _1 = expr _2 = TXOR _3 = expr
    {                  ( Binary(_1,(Arith Xor,_2),_3) )}
| _1 = expr _2 = T_SL _3 = expr
    {                  ( Binary(_1,(Arith DecLeft,_2),_3) )}
| _1 = expr _2 = T_SR _3 = expr
    {                  ( Binary(_1,(Arith DecRight,_2),_3) )}
| _1 = expr _2 = TDOT _3 = expr
    {                   ( Binary(_1,(BinaryConcat,_2),_3) )}
| _1 = expr _2 = T_IS_IDENTICAL _3 = expr
    {                                   ( Binary(_1,(Logical Identical,_2),_3) )}
| _1 = expr _2 = T_IS_NOT_IDENTICAL _3 = expr
    {                                   ( Binary(_1,(Logical NotIdentical,_2),_3) )}
| _1 = expr _2 = T_IS_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical Eq,_2),_3) )}
| _1 = expr _2 = T_IS_NOT_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical NotEq,_2),_3) )}
| _1 = expr _2 = TSMALLER _3 = expr
    {                                   ( Binary(_1,(Logical Inf,_2),_3) )}
| _1 = expr _2 = T_IS_SMALLER_OR_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical InfEq,_2),_3) )}
| _1 = expr _2 = TGREATER _3 = expr
    {                                   ( Binary(_1,(Logical Sup,_2),_3) )}
| _1 = expr _2 = T_IS_GREATER_OR_EQUAL _3 = expr
    {                                   ( Binary(_1,(Logical SupEq,_2),_3) )}
| _1 = TPLUS _2 = expr %prec T_INC
    {                                        ( Unary((UnPlus,_1),_2) )}
| _1 = TMINUS _2 = expr %prec T_INC
    {                                        ( Unary((UnMinus,_1),_2) )}
| _1 = TBANG _2 = expr
    {                                        ( Unary((UnBang,_1),_2) )}
| _1 = TTILDE _2 = expr
    {                                        ( Unary((UnTilde,_1),_2) )}
| _1 = expr _2 = TQUESTION _3 = expr _4 = TCOLON _5 = expr
    {                                      ( CondExpr(_1,_2,Some _3,_4,_5) )}
| _1 = expr _2 = TQUESTION _3 = TCOLON _4 = expr
    {                                 ( CondExpr(_1,_2,None,_3,_4) )}
| _1 = expr _2 = TQUESTION _3 = expr _4 = T_XHP_COLONID_DEF
    {     ( H.failwith_xhp_ambiguity_colon (snd _4) )}
| _1 = expr _2 = T_INSTANCEOF _3 = expr
    {                           ( InstanceOf(_1, _2, _3) )}
| _1 = T_BOOL_CAST _2 = expr
    {                      ( Cast((BoolTy,_1),_2) )}
| _1 = T_INT_CAST _2 = expr
    {                       ( Cast((IntTy,_1),_2) )}
| _1 = T_DOUBLE_CAST _2 = expr
    {                       ( Cast((DoubleTy,_1),_2) )}
| _1 = T_STRING_CAST _2 = expr
    {                      ( Cast((StringTy,_1),_2) )}
| _1 = T_ARRAY_CAST _2 = expr
    {                       ( Cast((ArrayTy,_1),_2) )}
| _1 = T_OBJECT_CAST _2 = expr
    {                       ( Cast((ObjectTy,_1),_2) )}
| _1 = T_UNSET_CAST _2 = expr
    {                      ( CastUnset(_1,_2) )}
| _1 = T_EXIT _2 = exit_expr
    {                    ( Exit(_1,_2) )}
| _1 = T__AT _2 = expr
    {                        ( At(_1,_2) )}
| _1 = T_PRINT _2 = expr
    {                 ( Print(_1,_2) )}
| _1 = T_CLONE _2 = expr
    {                ( Clone(_1,_2) )}
| _1 = async_opt _2 = T_FUNCTION _3 = is_reference _4 = TOPAR _5 = parameter_list _6 = TCPAR _7 = return_type_opt _8 = lexical_vars _9 = TOBRACE _10 = inner_statement_list _11 = TCBRACE
    {   ( let params = (_4, _5, _6) in
       let body = (_9, _10, _11) in
       Lambda (_8, { f_tok = _2;f_ref = _3;f_params = params; f_body = body;
                     f_tparams = None;
                     f_name = Name("__lambda__", _2);
                     f_return_type = _7; f_type = FunctionLambda;
                     f_modifiers = _1;
                     f_attrs = None;
       })
   )}
| _1 = lambda_expr
    {               ( _1 )}
| _1 = T_YIELD _2 = expr
    {                             ( Yield (_1, ArrayExpr _2) )}
| _1 = T_YIELD _2 = expr _3 = T_ARROW _4 = expr
    {                             ( Yield (_1, ArrayArrowExpr (_2, _3, _4)) )}
| _1 = T_YIELD _2 = T_BREAK
    {                   ( YieldBreak (_1, _2) )}
| _1 = T_AWAIT _2 = expr
    {                ( Await (_1, _2) )}
| _1 = T_ELLIPSIS
    {              ( H.sgrep_guard (SgrepExprDots _1) )}
| _1 = T_INCLUDE _2 = expr
    {                                ( Include(_1,_2) )}
| _1 = T_INCLUDE_ONCE _2 = expr
    {                                       ( IncludeOnce(_1,_2) )}
| _1 = T_REQUIRE _2 = expr
    {                               ( Require(_1,_2) )}
| _1 = T_REQUIRE_ONCE _2 = expr
    {                               ( RequireOnce(_1,_2) )}
| _1 = T_EMPTY _2 = TOPAR _3 = expr _4 = TCPAR
    {                                   ( Empty(_1,(_2,_3,_4)) )}
| _1 = T_EVAL _2 = TOPAR _3 = expr _4 = TCPAR
    {                                   ( Eval(_1,(_2,_3,_4)) )}
| _1 = T_ISSET _2 = TOPAR _3 = expr_list _4 = TCPAR
    {                                 ( Isset(_1, (_2, _3, _4)) )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR _5 = TEQ _6 = expr
    {     ( AssignList(_1,(_2,_3,_4),_5,_6) )}

simple_expr:
  _1 = new_expr
    {            ( _1 )}
| _1 = call_expr
    {             ( _1 )}
| _1 = qualified_class_name _2 = TOBRACE _3 = array_pair_list _4 = TCBRACE
    {     ( Collection (_1, (_2, _3, _4)) )}

new_expr:
  _1 = member_expr
    {               ( _1 )}
| _1 = T_NEW _2 = member_expr
    {                     ( New (_1, _2, None) )}
| _1 = T_NEW _2 = member_expr _3 = arguments
    {                               ( New (_1, _2, Some _3) )}

call_expr:
  _1 = member_expr _2 = arguments
    {                         ( Call (_1, _2) )}
| _1 = call_expr _2 = arguments
    {                       ( Call (_1, _2) )}
| _1 = call_expr _2 = TOBRA _3 = dim_offset _4 = TCBRA
    {                                    ( ArrayGet(_1, (_2, _3, _4)) )}
| _1 = call_expr _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                                    ( HashGet(_1, (_2, _3, _4)) )}
| _1 = call_expr _2 = T_OBJECT_OPERATOR _3 = primary_expr
    {                                            ( ObjGet(_1, _2, _3) )}
| _1 = call_expr _2 = T_OBJECT_OPERATOR _3 = TOBRACE _4 = expr _5 = TCBRACE
    {     ( ObjGet(_1,_2, (BraceIdent (_3, _4, _5))) )}

member_expr:
  _1 = primary_expr
    {                ( _1 )}
| _1 = member_expr _2 = TOBRA _3 = dim_offset _4 = TCBRA
    {                                      ( ArrayGet(_1, (_2, _3, _4)) )}
| _1 = member_expr _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                                      ( HashGet(_1, (_2, _3, _4)) )}
| _1 = member_expr _2 = T_OBJECT_OPERATOR _3 = primary_expr
    {                                              (  ObjGet(_1, _2, _3) )}
| _1 = member_expr _2 = T_OBJECT_OPERATOR _3 = TOBRACE _4 = expr _5 = TCBRACE
    {     ( ObjGet(_1,_2, (BraceIdent (_3, _4, _5))) )}
| _1 = member_expr _2 = TCOLCOL _3 = primary_expr
    {                                    ( ClassGet(_1, _2, _3) )}
| _1 = member_expr _2 = TCOLCOL _3 = T_CLASS
    {     ( ClassGet(_1, _2, Id (XName [QI (Name("class", _3))])) )}

primary_expr:
  _1 = constant
    {            ( Sc (C _1) )}
| _1 = qualified_class_name
    {                        ( Id _1  )}
| _1 = T_SELF
    {                        ( Id (Self _1) )}
| _1 = T_PARENT
    {                        ( Id (Parent _1) )}
| _1 = T_STATIC
    {                        ( Id (LateStatic _1) )}
| _1 = T_VARIABLE
    {              ( H.mk_var _1 )}
| _1 = TDOLLAR _2 = primary_expr
    {                                ( Deref(_1, _2) )}
| _1 = TDOLLAR _2 = TOBRACE _3 = expr _4 = TCBRACE
    {                                ( Deref(_1, BraceIdent(_2, _3, _4)) )}
| _1 = T_ARRAY _2 = TOPAR _3 = array_pair_list _4 = TCPAR
    {     ( ArrayLong(_1,(_2,_3,_4)) )}
| _1 = T_SHAPE _2 = TOPAR _3 = array_pair_list _4 = TCPAR
    {     ( ArrayLong(_1,(_2,_3,_4)) )}
| _1 = TOBRA _2 = array_pair_list _3 = TCBRA
    {     ( ArrayShort(_1, _2, _3) )}
| _1 = TGUIL _2 = encaps_list _3 = TGUIL
    {     ( Sc (Guil (_1, _2, _3)) )}
| _1 = TBACKQUOTE _2 = encaps_list _3 = TBACKQUOTE
    {     ( BackQuote(_1,_2,_3) )}
| _1 = T_START_HEREDOC _2 = encaps_list _3 = T_END_HEREDOC
    {     ( Sc (HereDoc (_1, _2, _3)) )}
| _1 = xhp_html
    {            ( XhpHtml _1 )}
| _1 = TOPAR _2 = expr _3 = TCPAR
    {                        ( ParenExpr(_1,_2,_3) )}

constant:
  _1 = T_LNUMBER
    {                ( Int(_1) )}
| _1 = T_DNUMBER
    {                ( Double(_1) )}
| _1 = T_CONSTANT_ENCAPSED_STRING
    {                              ( String(_1) )}
| _1 = T_LINE
    {          ( PreProcess(Line, _1) )}
| _1 = T_FILE
    {          ( PreProcess(File, _1) )}
| _1 = T_DIR
    {                                           ( PreProcess(Dir, _1) )}
| _1 = T_CLASS_C
    {             ( PreProcess(ClassC, _1) )}
| _1 = T_TRAIT_C
    {                                                    ( PreProcess(TraitC, _1))}
| _1 = T_FUNC_C
    {            ( PreProcess(FunctionC, _1) )}
| _1 = T_METHOD_C
    {                                                     ( PreProcess(MethodC, _1))}
| _1 = T_NAMESPACE_C
    {                 ( PreProcess(NamespaceC, _1) )}

static_scalar:
  _1 = expr
    {                    ( _1 )}

assignment_list_element:
  _1 = expr
    {           ( ListVar _1 )}
| _1 = T_LIST _2 = TOPAR _3 = assignment_list _4 = TCPAR
    {                                      ( ListList (_1, (_2, _3, _4)) )}
| 
    {                   ( ListEmpty )}

array_pair_list:
  _1 = array_pair_list_rev
    {                                     ( List.rev _1 )}

array_pair:
  _1 = expr
    {                  ( (ArrayExpr _1) )}
| _1 = TAND _2 = expr
    {                      ( (ArrayRef (_1,_2)) )}
| _1 = expr _2 = T_ARROW _3 = expr
    {                            ( (ArrayArrowExpr(_1,_2,_3)) )}
| _1 = expr _2 = T_ARROW _3 = TAND _4 = expr
    {                          ( (ArrayArrowRef(_1,_2,_3,_4)) )}

arguments:
  _1 = TOPAR _2 = function_call_argument_list _3 = TCPAR
    {                                                   ( (_1, _2, _3) )}

function_call_argument:
  _1 = expr
    {        ( (Arg (_1)) )}
| _1 = TAND _2 = expr
    {               ( (ArgRef(_1, _2)) )}
| _1 = T_ELLIPSIS _2 = expr
    {                        ( (ArgUnpack(_1, _2)) )}

encaps:
  _1 = T_ENCAPSED_AND_WHITESPACE
    {     ( EncapsString _1 )}
| _1 = T_VARIABLE
    {     ( EncapsVar (H.mk_var _1)  )}
| _1 = T_VARIABLE _2 = TOBRA _3 = encaps_var_offset _4 = TCBRA
    {     ( EncapsVar (ArrayGet (H.mk_var _1,(_2,Some _3,_4))))}
| _1 = T_VARIABLE _2 = T_OBJECT_OPERATOR _3 = T_IDENT
    {     ( EncapsVar (ObjGet(H.mk_var _1, _2, Id (XName [QI (Name _3)]))))}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = T_STRING_VARNAME _3 = TCBRACE
    {     (
       (* this is not really a T_VARIABLE, bit it's still conceptually
        * a variable so we build it almost like above
        *)
       let var = H.mk_var _2 in
       EncapsDollarCurly (_1, var, _3)
     )}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = T_STRING_VARNAME _3 = TOBRA _4 = expr _5 = TCBRA _6 = TCBRACE
    {     (
       let lval = ArrayGet(H.mk_var _2, (_3, Some _4, _5))
       in
       EncapsDollarCurly (_1,  lval, _6)
     )}
| _1 = T_CURLY_OPEN _2 = expr _3 = TCBRACE
    {                                       ( EncapsCurly(_1, _2, _3) )}
| _1 = T_DOLLAR_OPEN_CURLY_BRACES _2 = expr _3 = TCBRACE
    {                                           ( EncapsExpr (_1, _2, _3) )}

encaps_var_offset:
  _1 = T_IDENT
    {           (
     (* It looks like an ident but as we are in encaps_var_offset,
      * PHP allows array access inside strings to omit the quote
      * around fieldname, so it's actually really a Constant (String)
      * rather than an ident, as we usually do for other T_IDENT
      * cases.
      *)
     let cst = String _1 in (* will not have enclosing "'"  as usual *)
     Sc (C cst)
   )}
| _1 = T_VARIABLE
    {              ( H.mk_var _1 )}
| _1 = T_NUM_STRING
    {                (
     (* the original php lexer does not return some numbers for
      * offset of array access inside strings. Not sure why ...
      *)
     let cst = String _1 in (* will not have enclosing "'"  as usual *)
     Sc (C cst)
   )}

xhp_html:
  _1 = T_XHP_OPEN_TAG _2 = xhp_attributes _3 = T_XHP_GT _4 = xhp_children _5 = T_XHP_CLOSE_TAG
    {     ( Xhp (_1, _2, _3, _4, _5)  )}
| _1 = T_XHP_OPEN_TAG _2 = xhp_attributes _3 = T_XHP_SLASH_GT
    {     ( XhpSingleton (_1, _2, _3) )}

xhp_child:
  _1 = T_XHP_TEXT
    {                        ( XhpText _1 )}
| _1 = xhp_html
    {                        ( XhpNested _1 )}
| _1 = TOBRACE _2 = expr _3 = TCBRACE
    {                        ( XhpExpr (_1, _2, _3) )}

xhp_attribute:
  _1 = T_XHP_ATTR _2 = TEQ _3 = xhp_attribute_value
    {                                      ( _1, _2, _3 )}

xhp_attribute_value:
  _1 = TGUIL _2 = encaps_list _3 = TGUIL
    {                           ( XhpAttrString (_1, _2, _3) )}
| _1 = TOBRACE _2 = expr _3 = TCBRACE
    {                           ( XhpAttrExpr (_1, _2, _3) )}
| _1 = T_XHP_ATTR
    {              ( H.sgrep_guard (SgrepXhpAttrValueMvar (_1)) )}

lambda_expr:
  _1 = T_VARIABLE _2 = lambda_body
    {     (
       let sl_tok, sl_body = _2 in
       let sl_params = SLSingleParam (H.mk_param _1) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [] }
     )}
| _1 = T_ASYNC _2 = T_VARIABLE _3 = lambda_body
    {     (
       let sl_tok, sl_body = _3 in
       let sl_params = SLSingleParam (H.mk_param _2) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [Async,(_1)] }
     )}
| _1 = T_LAMBDA_OPAR _2 = parameter_list _3 = T_LAMBDA_CPAR _4 = return_type_opt _5 = lambda_body
    {     (
       let sl_tok, sl_body = _5 in
       let sl_params = SLParams (_1, _2, _3) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = []; }
     )}
| _1 = T_ASYNC _2 = T_LAMBDA_OPAR _3 = parameter_list _4 = T_LAMBDA_CPAR _5 = return_type_opt _6 = lambda_body
    {     (
       let sl_tok, sl_body = _6 in
       let sl_params = SLParams (_2, _3, _4) in
       ShortLambda { sl_params; sl_tok; sl_body; sl_modifiers = [Async,(_1)]; }
     )}
| _1 = T_ASYNC _2 = TOBRACE _3 = inner_statement_list _4 = TCBRACE
    {     (
       let sl_body = SLBody (_2, _3, _4) in
       ShortLambda { sl_params = SLParamsOmitted;
                     sl_tok = None;
                     sl_body;
                     sl_modifiers = [Async,(_1)];
                   }
     )}

lambda_body:
  _1 = T_DOUBLE_ARROW _2 = TOBRACE _3 = inner_statement_list _4 = TCBRACE
    {                                                       ( (Some _1, SLBody (_2, _3, _4)) )}
| _1 = T_DOUBLE_ARROW _2 = expr
    {                       ( (Some _1, SLExpr _2) )}

dim_offset:
  
    {                   ( None )}
| _1 = expr
    {            ( Some _1 )}

exit_expr:
  
    {                 ( None )}
| _1 = TOPAR _2 = TCPAR
    {                ( Some(_1, None, _2) )}
| _1 = TOPAR _2 = expr _3 = TCPAR
    {                    ( Some(_1, Some _2, _3) )}

ident:
  _1 = T_IDENT
    {           ( _1 )}
| _1 = T_XHP_ATTRIBUTE
    {                   ( PI.str_of_info _1, _1 )}
| _1 = T_XHP_CATEGORY
    {                   ( PI.str_of_info _1, _1 )}
| _1 = T_XHP_CHILDREN
    {                   ( PI.str_of_info _1, _1 )}
| _1 = T_ENUM
    {            ( PI.str_of_info _1, _1 )}
| _1 = T_XHP_ANY
    {                ( PI.str_of_info _1, _1 )}
| _1 = T_XHP_PCDATA
    {                ( PI.str_of_info _1, _1 )}
| _1 = T_TYPE
    {               ( PI.str_of_info _1, _1 )}
| _1 = T_NEWTYPE
    {               ( PI.str_of_info _1, _1 )}
| _1 = T_SUPER
    {               ( PI.str_of_info _1, _1 )}

ident_class_name:
  _1 = ident
    {                      ( Name _1 )}
| _1 = T_XHP_COLONID_DEF
    {                      ( XhpName _1 )}

ident_method_name:
  _1 = ident
    {         ( _1 )}
| _1 = T_PARENT
    {            ( "parent", _1 )}
| _1 = T_SELF
    {            ( "self", _1 )}
| _1 = T_ASYNC
    {            ( "async", _1 )}

ident_xhp_attr_name_atom:
  _1 = ident
    {         ( snd _1 )}
| _1 = T_ECHO
    {          ( _1 )}
| _1 = T_PRINT
    {                           ( _1 )}
| _1 = T_IF
    {                                         ( _1 )}
| _1 = T_ELSE
    {                                                         ( _1 )}
| _1 = T_ELSEIF
    {            ( _1 )}
| _1 = T_ENDIF
    {                             ( _1 )}
| _1 = T_DO
    {                                           ( _1 )}
| _1 = T_WHILE
    {                                                            ( _1 )}
| _1 = T_ENDWHILE
    {              ( _1 )}
| _1 = T_FOR
    {                             ( _1 )}
| _1 = T_ENDFOR
    {                                               ( _1 )}
| _1 = T_FOREACH
    {                                                                  ( _1 )}
| _1 = T_ENDFOREACH
    {                ( _1 )}
| _1 = T_SWITCH
    {                                  ( _1 )}
| _1 = T_ENDSWITCH
    {                                                       ( _1 )}
| _1 = T_CASE
    {                                                                       ( _1 )}
| _1 = T_DEFAULT
    {             ( _1 )}
| _1 = T_BREAK
    {                              ( _1 )}
| _1 = T_CONTINUE
    {                                                  ( _1 )}
| _1 = T_RETURN
    {                                                                    ( _1 )}
| _1 = T_TRY
    {         ( _1 )}
| _1 = T_CATCH
    {                          ( _1 )}
| _1 = T_FINALLY
    {                                             ( _1 )}
| _1 = T_THROW
    {                                                              ( _1 )}
| _1 = T_EXIT
    {          ( _1 )}
| _1 = T_DECLARE
    {                             ( _1 )}
| _1 = T_ENDDECLARE
    {                                                   ( _1 )}
| _1 = T_USE
    {                                                                  ( _1 )}
| _1 = T_GLOBAL
    {            ( _1 )}
| _1 = T_AS
    {                          ( _1 )}
| _1 = T_FUNCTION
    {                                              ( _1 )}
| _1 = T_CONST
    {                                                               ( _1 )}
| _1 = T_STATIC
    {            ( _1 )}
| _1 = T_ABSTRACT
    {                                ( _1 )}
| _1 = T_FINAL
    {                                                 ( _1 )}
| _1 = T_PRIVATE
    {                                                                    ( _1 )}
| _1 = T_PROTECTED
    {               ( _1 )}
| _1 = T_PUBLIC
    {                                 ( _1 )}
| _1 = T_VAR
    {                                                ( _1 )}
| _1 = T_UNSET
    {                                                                 ( _1 )}
| _1 = T_ISSET
    {           ( _1 )}
| _1 = T_EMPTY
    {                            ( _1 )}
| _1 = T_CLASS
    {                                             ( _1 )}
| _1 = T_INTERFACE
    {               ( _1 )}
| _1 = T_EXTENDS
    {                                  ( _1 )}
| _1 = T_IMPLEMENTS
    {                                                        ( _1 )}
| _1 = T_LIST
    {                                                                        ( _1 )}
| _1 = T_ARRAY
    {           ( _1 )}
| _1 = T_CLASS_C
    {                              ( _1 )}
| _1 = T_METHOD_C
    {                                                  ( _1 )}
| _1 = T_FUNC_C
    {                                                                    ( _1 )}
| _1 = T_LINE
    {          ( _1 )}
| _1 = T_FILE
    {                          ( _1 )}
| _1 = T_LOGICAL_OR
    {                                                ( _1 )}
| _1 = T_LOGICAL_AND
    {                                                                       ( _1 )}
| _1 = T_LOGICAL_XOR
    {                 ( _1 )}
| _1 = T_NEW
    {                                ( _1 )}
| _1 = T_CLONE
    {                                                 ( _1 )}
| _1 = T_INSTANCEOF
    {                                                                       ( _1 )}
| _1 = T_INCLUDE
    {             ( _1 )}
| _1 = T_INCLUDE_ONCE
    {                                     ( _1 )}
| _1 = T_REQUIRE
    {                                                        ( _1 )}
| _1 = T_REQUIRE_ONCE
    {                  ( _1 )}
| _1 = T_EVAL
    {                                  ( _1 )}
| _1 = T_SELF
    {                                                  ( _1 )}
| _1 = T_PARENT
    {                                                                    ( _1 )}
| _1 = T_TRAIT
    {           ( _1 )}
| _1 = T_INSTEADOF
    {                                ( _1 )}
| _1 = T_TRAIT_C
    {                                                   ( _1 )}
| _1 = T_NAMESPACE
    {               ( _1 )}
| _1 = T_NAMESPACE_C
    {                                      ( _1 )}
| _1 = T_ASYNC
    {           ( _1 )}
| _1 = T_AWAIT
    {                            ( _1 )}

namespace_declaration:
  _1 = T_NAMESPACE _2 = namespace_name _3 = TSEMICOLON
    {     ( NamespaceDef (_1, _2, _3) )}
| _1 = T_NAMESPACE _2 = namespace_name _3 = TOBRACE _4 = top_statement_list _5 = TCBRACE
    {     ( NamespaceBracketDef (_1, Some _2, (_3, H.squash_stmt_list _4, _5)) )}
| _1 = T_NAMESPACE _2 = TOBRACE _3 = top_statement_list _4 = TCBRACE
    {     ( NamespaceBracketDef (_1, None, (_2, H.squash_stmt_list _3, _4)) )}

use_declaration:
  _1 = T_USE _2 = use_declaration_name_list _3 = TSEMICOLON
    {                                              ( NamespaceUse (_1, _2, _3) )}

namespace_name:
  _1 = ident
    {                                   ( [QI (Name _1)] )}
| _1 = namespace_name _2 = TANTISLASH _3 = ident
    {                                   ( _1 @ [QITok _2; QI (Name _3)] )}

use_declaration_name:
  _1 = namespace_name
    {                  ( ImportNamespace _1 )}
| _1 = namespace_name _2 = T_AS _3 = ident
    {                             ( AliasNamespace (_1, _2, Name _3) )}
| _1 = TANTISLASH _2 = namespace_name
    {                             ( ImportNamespace (QITok _1::_2) )}
| _1 = TANTISLASH _2 = namespace_name _3 = T_AS _4 = ident
    {     ( AliasNamespace (QITok _1::_2, _3, Name _4) )}

qualified_name:
  _1 = namespace_name
    {                                         ( XName _1 )}
| _1 = TANTISLASH _2 = namespace_name
    {                                         ( XName (QITok _1::_2) )}
| _1 = T_NAMESPACE _2 = TANTISLASH _3 = namespace_name
    {     ( XName (QI (Name ("namespace", _1))::QITok _2::_3) )}

qualified_class_name:
  _1 = qualified_name
    {                   ( _1 )}
| _1 = T_XHP_COLONID_DEF
    {                      ( XName [QI (XhpName _1)] )}

qualified_class_name_or_array:
  _1 = qualified_class_name
    {                        ( _1 )}
| _1 = T_ARRAY
    {           ( XName [QI (Name ("array", _1))] )}

qualified_name_for_traits:
  _1 = qualified_class_name
    {                                                ( _1 )}

class_name:
  _1 = qualified_class_name_or_array _2 = type_arguments
    {  ( Hint (_1, _2) )}

class_name_no_array:
  _1 = qualified_class_name _2 = type_arguments
    {  ( Hint (_1, _2) )}

top_statement_list:
  _1 = top_statement_list _2 = top_statement
    {                                     ( _1 @ [_2] )}
| 
    {                 ( [] )}

inner_statement_list:
  _1 = inner_statement_list _2 = inner_statement
    {                                         ( _1 @ [_2] )}
| 
    {                 ( [] )}

class_statement_list:
  _1 = class_statement_list _2 = class_statement
    {                                        ( _1 @ [_2] )}
| 
    {                 ( [] )}

enum_statement_list:
  _1 = enum_statement_list _2 = enum_statement
    {                                      ( _1 @ [_2] )}
| 
    {                 ( [] )}

trait_rules:
  _1 = trait_rules _2 = trait_rule
    {                          ( _1 @ [_2] )}
| 
    {                 ( [] )}

additional_catches:
  _1 = non_empty_additional_catches
    {                                ( _1 )}
| 
    {                 ( [] )}

non_empty_additional_catches:
  _1 = additional_catch
    {                                                 ( [_1] )}
| _1 = non_empty_additional_catches _2 = additional_catch
    {                                                 ( _1 @ [_2] )}

optional_finally_clause:
  _1 = finally_clause
    {                  ( [_1] )}
| 
    {                  ( [] )}

method_modifiers:
  
    {                    ( [] )}
| _1 = non_empty_member_modifiers
    {                                ( _1 )}

non_empty_member_modifiers:
  _1 = member_modifier
    {                      ( [_1] )}
| _1 = non_empty_member_modifiers _2 = member_modifier
    {                                              ( _1 @ [_2] )}

unset_variables:
  _1 = unset_variable
    {                  ( [Left _1] )}
| _1 = unset_variables _2 = TCOMMA _3 = unset_variable
    {                                         ( _1 @ [Right _2; Left _3] )}

global_var_list:
  _1 = global_var
    {                 ( [Left _1] )}
| _1 = global_var_list _2 = TCOMMA _3 = global_var
    {                                     ( _1 @ [Right _2; Left _3] )}

echo_expr_list:
  _1 = expr
    {              ( [Left _1] )}
| _1 = echo_expr_list _2 = TCOMMA _3 = expr
    {                                   ( _1 @ [Right _2; Left _3] )}

expr_list:
  _1 = expr
    {              ( [Left _1] )}
| _1 = expr_list _2 = TCOMMA _3 = expr
    {                              ( _1 @ [Right _2; Left _3] )}

use_declaration_name_list:
  _1 = use_declaration_name
    {     ( [Left _1] )}
| _1 = use_declaration_name_list _2 = TCOMMA _3 = use_declaration_name
    {     ( _1@[Right _2;Left _3] )}

declare_list:
  _1 = declare
    {                               ( [Left _1] )}
| _1 = declare_list _2 = TCOMMA _3 = declare
    {                               ( _1 @ [Right _2; Left _3] )}

non_empty_for_expr:
  _1 = expr
    {                      ( [Left _1] )}
| _1 = non_empty_for_expr _2 = TCOMMA _3 = expr
    {                                   ( _1 @ [Right _2; Left _3] )}

xhp_attribute_decls:
  _1 = xhp_attribute_decl
    {                      ( [Left _1] )}
| _1 = xhp_attribute_decls _2 = TCOMMA _3 = xhp_attribute_decl
    {                                                 ( _1 @ [Right _2; Left _3] )}

xhp_enum_list:
  _1 = xhp_enum
    {            ( [Left _1] )}
| _1 = xhp_enum_list _2 = TCOMMA _3 = xhp_enum
    {                                 ( _1 @ [Right _2; Left _3] )}

xhp_category_list:
  _1 = xhp_category
    {                ( [Left _1] )}
| _1 = xhp_category_list _2 = TCOMMA _3 = xhp_category
    {                                         ( _1 @ [Right _2; Left _3] )}

attribute_list:
  _1 = attribute
    {                   ( [Left _1] )}
| _1 = attribute_list _2 = TCOMMA _3 = attribute
    {                                           ( _1 @ [Right _2; Left _3] )}

attribute_argument_list:
  
    {                 ( [] )}
| _1 = attribute_argument
    {                      ( [Left _1] )}
| _1 = attribute_argument_list _2 = TCOMMA _3 = attribute_argument
    {                                                     ( _1@[Right _2; Left _3])}

static_var_list:
  _1 = static_var
    {                                     ( [Left _1] )}
| _1 = static_var_list _2 = TCOMMA _3 = static_var
    {                                     ( _1 @ [Right _2; Left _3] )}

class_variable_declaration:
  _1 = class_variable
    {                     ( [Left _1] )}
| _1 = class_variable_declaration _2 = TCOMMA _3 = class_variable
    {                                                    ( _1@[Right _2;Left _3] )}

non_empty_parameter_list:
  _1 = parameter_or_dots
    {                                                      ( [_1] )}
| _1 = non_empty_parameter_list _2 = TCOMMA _3 = parameter_or_dots
    {                                                      ( _1 @ [Right3 _2; _3] )}

non_empty_type_php_or_dots_list:
  _1 = type_php_or_dots
    {                                                        ( [_1] )}
| _1 = non_empty_type_php_or_dots_list _2 = TCOMMA _3 = type_php_or_dots
    {                                                           ( _1 @ [Right3 _2; _3])}

non_empty_type_php_list:
  _1 = non_empty_type_php_list_bis
    {                               ( _1 )}
| _1 = non_empty_type_php_list_bis _2 = TCOMMA
    {                                      ( _1 @ [Right _2] )}

non_empty_type_php_list_bis:
  _1 = type_php
    {                                           ( [Left _1] )}
| _1 = non_empty_type_php_list_bis _2 = TCOMMA _3 = type_php
    {                                                ( _1 @ [Right _2; Left _3] )}

class_name_list:
  _1 = class_name_no_array
    {                       ( [Left _1] )}
| _1 = class_name_list _2 = TCOMMA _3 = class_name_no_array
    {                                              ( _1 @ [Right _2; Left _3])}

class_constants_declaration:
  _1 = class_constant_declaration
    {                              ( [Left _1] )}
| _1 = class_constants_declaration _2 = TCOMMA _3 = class_constant_declaration
    {     ( _1 @ [Right _2; Left _3] )}

possible_comma:
  
    {                 ( [] )}
| _1 = TCOMMA
    {                 ( [Right _1] )}

return_type_opt:
  _1 = return_type
    {                     ( Some _1 )}
| 
    {                     ( None )}

attributes_opt:
  _1 = attributes
    {                  ( Some _1 )}
| 
    {                  ( None )}

type_php_opt:
  _1 = type_php
    {                  ( Some _1 )}
| 
    {                  ( None )}

at_opt:
  _1 = T__AT
    {                  ( Some _1 )}
| 
    {                  ( None )}

ctor_modifier_opt:
  _1 = ctor_modifier
    {                       ( Some _1 )}
| 
    {                  ( None )}

function_call_argument_list:
  
    {                                              ( [] )}
| _1 = non_empty_function_call_argument_list
    {                                              ( _1 )}
| _1 = non_empty_function_call_argument_list _2 = TCOMMA
    {                                                 ( _1 @ [Right _2] )}

non_empty_function_call_argument_list:
  _1 = function_call_argument
    {                          ( [Left _1] )}
| _1 = non_empty_function_call_argument_list _2 = TCOMMA _3 = function_call_argument
    {      ( _1 @ [Right _2; Left _3] )}

assignment_list:
  _1 = assignment_list_element
    {                                                  ( [Left _1] )}
| _1 = assignment_list _2 = TCOMMA _3 = assignment_list_element
    {                                                  ( _1 @ [Right _2; Left _3] )}

shape_field_list:
  
    {                 ( [] )}
| _1 = non_empty_shape_field_list
    {                              ( _1 )}
| _1 = non_empty_shape_field_list _2 = TCOMMA
    {                                     ( _1 @ [Right _2] )}

non_empty_shape_field_list:
  _1 = shape_field
    {                 ( [Left _1] )}
| _1 = non_empty_shape_field_list _2 = TCOMMA _3 = shape_field
    {                                                  ( _1 @ [Right _2; Left _3] )}

non_empty_array_pair_list_rev:
  _1 = array_pair
    {              ( [Left _1] )}
| _1 = non_empty_array_pair_list_rev _2 = TCOMMA _3 = array_pair
    {                                                    ( Left _3::Right _2::_1 )}

array_pair_list_rev:
  
    {                 ( [] )}
| _1 = non_empty_array_pair_list_rev _2 = possible_comma
    {                                                ( _2@_1 )}

encaps_list:
  _1 = encaps_list _2 = encaps
    {                                       ( _1 @ [_2] )}
| 
    {                 ( [] )}

xhp_attributes:
  _1 = xhp_attributes _2 = xhp_attribute
    {                                ( _1 @ [_2] )}
| 
    {                 ( [] )}

xhp_children:
  _1 = xhp_children _2 = xhp_child
    {                          ( _1 @ [_2] )}
| 
    {                 ( [] )}

%%


