File "parser_cpp.mly", line 147, characters 25-36:
Warning: the token TAny_Action is unused.
File "parser_cpp.mly", line 50, characters 55-63:
Warning: the token TComment is unused.
File "parser_cpp.mly", line 50, characters 39-54:
Warning: the token TCommentNewline is unused.
File "parser_cpp.mly", line 50, characters 25-38:
Warning: the token TCommentSpace is unused.
File "parser_cpp.mly", line 55, characters 60-72:
Warning: the token TComment_Cpp is unused.
File "parser_cpp.mly", line 53, characters 54-65:
Warning: the token TComment_Pp is unused.
File "parser_cpp.mly", line 117, characters 25-43:
Warning: the token TCppEscapedNewline is unused.
File "parser_cpp.mly", line 177, characters 25-41:
Warning: the token TInt_ZeroVirtual is unused.
File "parser_cpp.mly", line 39, characters 25-33:
Warning: the token TUnknown is unused.
File "parser_cpp.mly", line 105, characters 25-35:
Warning: the token Tattribute is unused.
File "parser_cpp.mly", line 165, characters 3-10:
Warning: the token Texport is unused.
File "parser_cpp.mly", line 196, characters 2-16:
Warning: the token Tsigned_Constr is unused.
File "parser_cpp.mly", line 196, characters 17-33:
Warning: the token Tunsigned_Constr is unused.
%{
(* Yoann Padioleau
 *
 * Copyright (C) 2010-2014 Facebook
 * Copyright (C) 2008-2009 University of Urbana Champaign
 * Copyright (C) 2006-2007 Ecole des Mines de Nantes
 * Copyright (C) 2002 Yoann Padioleau
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License (GPL)
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * file license.txt for more details.
 *)
open Common

open Ast_cpp
open Parser_cpp_mly_helper

(* see todo_mly for stuff temporarily commented out *)

%}
%start expr
%start main
%start statement
%start toplevel
%start type_id
%token <Parse_info.info> EOF
%token <Parse_info.info> TAnd
%token <Parse_info.info> TAndLog
%token <Parse_info.info> TAny_Action
%token <Ast_cpp.assignOp * Parse_info.info> TAssign
%token <Parse_info.info> TBang
%token <Parse_info.info> TCBrace
%token <Parse_info.info> TCCro
%token <Parse_info.info> TCCro_new
%token <Parse_info.info> TCPar
%token <Parse_info.info> TCPar_EOL
%token <(string * Ast_cpp.isWchar) * Parse_info.info> TChar
%token <Parse_info.info> TCol
%token <Parse_info.info> TColCol
%token <Parse_info.info> TColCol_BeforeTypedef
%token <Parse_info.info> TComma
%token <Parse_info.info> TComment
%token <Parse_info.info> TCommentNewline
%token <Parse_info.info> TCommentNewline_DefineEndOfMacro
%token <Parse_info.info> TCommentSpace
%token <(Token_cpp.cpluspluscommentkind * Parse_info.info)> TComment_Cpp
%token <(Token_cpp.cppcommentkind * Parse_info.info)> TComment_Pp
%token <Parse_info.info> TCppDirectiveOther
%token <Parse_info.info> TCppEscapedNewline
%token <Parse_info.info> TDec
%token <(string * Parse_info.info)> TDefParamVariadic
%token <Parse_info.info> TDefine
%token <Parse_info.info> TDiv
%token <Parse_info.info> TDot
%token <Parse_info.info> TDotStar
%token <Parse_info.info> TEllipsis
%token <Parse_info.info> TEndif
%token <Parse_info.info> TEq
%token <Parse_info.info> TEqEq
%token <(string * Ast_cpp.floatType) * Parse_info.info> TFloat
%token <string * Parse_info.info> TIdent
%token <string * Parse_info.info> TIdent_ClassnameInQualifier
%token <string * Parse_info.info> TIdent_ClassnameInQualifier_BeforeTypedef
%token <string * Parse_info.info> TIdent_Constructor
%token <(string * Parse_info.info)> TIdent_Define
%token <(string * Parse_info.info)> TIdent_MacroDecl
%token <(string * Parse_info.info)> TIdent_MacroIterator
%token <Parse_info.info> TIdent_MacroStmt
%token <Parse_info.info> TIdent_MacroString
%token <string * Parse_info.info> TIdent_Templatename
%token <string * Parse_info.info> TIdent_TemplatenameInQualifier
%token <string * Parse_info.info> TIdent_TemplatenameInQualifier_BeforeTypedef
%token <string * Parse_info.info> TIdent_Typedef
%token <string * Parse_info.info> TIdent_TypedefConstr
%token <Parse_info.info> TIfdef
%token <(bool * Parse_info.info)> TIfdefBool
%token <(bool * Parse_info.info)> TIfdefMisc
%token <(bool * Parse_info.info)> TIfdefVersion
%token <Parse_info.info> TIfdefelif
%token <Parse_info.info> TIfdefelse
%token <Parse_info.info> TInc
%token <(string * string * Parse_info.info)> TInclude
%token <Parse_info.info> TInf
%token <Parse_info.info> TInfEq
%token <Parse_info.info> TInf_Template
%token <string * Parse_info.info> TInt
%token <Parse_info.info> TInt_ZeroVirtual
%token <Parse_info.info> TMinus
%token <Parse_info.info> TMod
%token <Parse_info.info> TMul
%token <Parse_info.info> TNotEq
%token <Parse_info.info> TOBrace
%token <Parse_info.info> TOBrace_DefineInit
%token <Parse_info.info> TOCro
%token <Parse_info.info> TOCro_new
%token <Parse_info.info> TOPar
%token <Parse_info.info> TOPar_CplusplusInit
%token <Parse_info.info> TOPar_Define
%token <Parse_info.info> TOr
%token <Parse_info.info> TOrLog
%token <Parse_info.info> TPlus
%token <Parse_info.info> TPtVirg
%token <Parse_info.info> TPtrOp
%token <Parse_info.info> TPtrOpStar
%token <Parse_info.info> TShl
%token <Parse_info.info> TShr
%token <(string * Ast_cpp.isWchar) * Parse_info.info> TString
%token <Parse_info.info> TSup
%token <Parse_info.info> TSupEq
%token <Parse_info.info> TSup_Template
%token <Parse_info.info> TTilde
%token <string * Parse_info.info> TUndef
%token <Parse_info.info> TUnknown
%token <Parse_info.info> TWhy
%token <Parse_info.info> TXor
%token <Parse_info.info> Tasm
%token <Parse_info.info> Tattribute
%token <Parse_info.info> Tauto
%token <Parse_info.info> Tbool
%token <Parse_info.info> Tbool_Constr
%token <Parse_info.info> Tbreak
%token <Parse_info.info> Tcase
%token <Parse_info.info> Tcatch
%token <Parse_info.info> Tchar
%token <Parse_info.info> Tchar_Constr
%token <Parse_info.info> Tclass
%token <Parse_info.info> Tconst
%token <Parse_info.info> Tconst_MacroDeclConst
%token <Parse_info.info> Tconst_cast
%token <Parse_info.info> Tcontinue
%token <Parse_info.info> Tdefault
%token <Parse_info.info> Tdelete
%token <Parse_info.info> Tdo
%token <Parse_info.info> Tdouble
%token <Parse_info.info> Tdouble_Constr
%token <Parse_info.info> Tdynamic_cast
%token <Parse_info.info> Telse
%token <Parse_info.info> Tenum
%token <Parse_info.info> Texplicit
%token <Parse_info.info> Texport
%token <Parse_info.info> Textern
%token <Parse_info.info> Tfalse
%token <Parse_info.info> Tfloat
%token <Parse_info.info> Tfloat_Constr
%token <Parse_info.info> Tfor
%token <Parse_info.info> Tfriend
%token <Parse_info.info> Tgoto
%token <Parse_info.info> Tif
%token <Parse_info.info> Tinline
%token <Parse_info.info> Tint
%token <Parse_info.info> Tint_Constr
%token <Parse_info.info> Tlong
%token <Parse_info.info> Tlong_Constr
%token <Parse_info.info> Tmutable
%token <Parse_info.info> Tnamespace
%token <Parse_info.info> Tnew
%token <Parse_info.info> Toperator
%token <Parse_info.info> Tprivate
%token <Parse_info.info> Tprotected
%token <Parse_info.info> Tpublic
%token <Parse_info.info> Tregister
%token <Parse_info.info> Treinterpret_cast
%token <Parse_info.info> Trestrict
%token <Parse_info.info> Treturn
%token <Parse_info.info> Tshort
%token <Parse_info.info> Tshort_Constr
%token <Parse_info.info> Tsigned
%token <Parse_info.info> Tsigned_Constr
%token <Parse_info.info> Tsizeof
%token <Parse_info.info> Tstatic
%token <Parse_info.info> Tstatic_cast
%token <Parse_info.info> Tstruct
%token <Parse_info.info> Tswitch
%token <Parse_info.info> Ttemplate
%token <Parse_info.info> Tthis
%token <Parse_info.info> Tthrow
%token <Parse_info.info> Ttrue
%token <Parse_info.info> Ttry
%token <Parse_info.info> Ttypedef
%token <Parse_info.info> Ttypeid
%token <Parse_info.info> Ttypename
%token <Parse_info.info> Ttypeof
%token <Parse_info.info> Tunion
%token <Parse_info.info> Tunsigned
%token <Parse_info.info> Tunsigned_Constr
%token <Parse_info.info> Tusing
%token <Parse_info.info> Tvirtual
%token <Parse_info.info> Tvoid
%token <Parse_info.info> Tvolatile
%token <Parse_info.info> Twchar_t
%token <Parse_info.info> Twchar_t_Constr
%token <Parse_info.info> Twhile
%nonassoc LOW_PRIORITY_RULE
%nonassoc Telse
%left TOrLog
%left TAndLog
%left TOr
%left TXor
%left TAnd
%left TEqEq TNotEq
%left TInf TInfEq TSup TSupEq
%left TShl TShr
%left TMinus TPlus
%left TDiv TMod TMul
%type <(Ast_cpp.name) * (Ast_cpp.fullType -> Ast_cpp.fullType)> declarator
%type <Ast_cpp.expression> expr
%type <Ast_cpp.program> main
%type <Ast_cpp.statement> statement
%type <Ast_cpp.toplevel option> toplevel
%type <(Ast_cpp.name)> type_cplusplus_id
%type <Ast_cpp.fullType> type_id
%%

main:
  _1 = translation_unit _2 = EOF
    {                            ( _1 )}

translation_unit:
  _1 = external_declaration
    {                                             ( [DeclElem _1] )}
| _1 = translation_unit _2 = external_declaration
    {                                             ( _1 @ [DeclElem _2] )}

external_declaration:
  _1 = function_definition
    {                                  ( Func (FunctionOrMethod _1) )}
| _1 = block_declaration
    {                                  ( BlockDecl _1 )}

id_expression:
  _1 = unqualified_id
    {                  ( noQscope, _1 )}
| _1 = qualified_id
    {                ( _1 )}

unqualified_id:
  _1 = TIdent
    {                          ( IdIdent _1 )}
| _1 = operator_function_id
    {                          ( _1 )}
| _1 = conversion_function_id
    {                          ( _1 )}

operator_function_id:
  _1 = Toperator _2 = operator_kind
    {    ( IdOperator (_1, _2) )}

conversion_function_id:
  _1 = Toperator _2 = conversion_type_id
    {    ( IdConverter (_1, _2) )}

operator_kind:
  _1 = TEqEq
    {          ( BinaryOp (Logical Eq),    [_1] )}
| _1 = TNotEq
    {          ( BinaryOp (Logical NotEq), [_1] )}
| _1 = TEq
    {           ( AssignOp SimpleAssign, [_1] )}
| _1 = TAssign
    {           ( AssignOp (fst _1), [snd _1] )}
| _1 = TTilde
    {          ( UnaryTildeOp, [_1] )}
| _1 = TBang
    {          ( UnaryNotOp,   [_1] )}
| _1 = TComma
    {          ( CommaOp,  [_1] )}
| _1 = TPlus
    {          ( BinaryOp (Arith Plus),  [_1] )}
| _1 = TMinus
    {          ( BinaryOp (Arith Minus), [_1] )}
| _1 = TMul
    {          ( BinaryOp (Arith Mul),   [_1] )}
| _1 = TDiv
    {          ( BinaryOp (Arith Div),   [_1] )}
| _1 = TMod
    {          ( BinaryOp (Arith Mod),   [_1] )}
| _1 = TOr
    {         ( BinaryOp (Arith Or),  [_1] )}
| _1 = TXor
    {         ( BinaryOp (Arith Xor), [_1] )}
| _1 = TAnd
    {         ( BinaryOp (Arith And), [_1]  )}
| _1 = TShl
    {          ( BinaryOp (Arith DecLeft), [_1] )}
| _1 = TShr
    {          ( BinaryOp (Arith DecRight), [_1] )}
| _1 = TOrLog
    {           ( BinaryOp (Logical OrLog), [_1] )}
| _1 = TAndLog
    {           ( BinaryOp (Logical AndLog), [_1] )}
| _1 = TInf
    {          ( BinaryOp (Logical Inf), [_1] )}
| _1 = TSup
    {          ( BinaryOp (Logical Sup), [_1] )}
| _1 = TInfEq
    {          ( BinaryOp (Logical InfEq), [_1] )}
| _1 = TSupEq
    {          ( BinaryOp (Logical SupEq), [_1] )}
| _1 = TInc
    {          ( FixOp Inc, [_1] )}
| _1 = TDec
    {          ( FixOp Dec, [_1] )}
| _1 = TPtrOpStar
    {              ( PtrOpOp PtrStarOp, [_1] )}
| _1 = TPtrOp
    {              ( PtrOpOp PtrOp,     [_1] )}
| _1 = TOPar _2 = TCPar
    {               ( AccessOp ParenOp, [_1;_2] )}
| _1 = TOCro _2 = TCCro
    {               ( AccessOp ArrayOp, [_1;_2] )}
| _1 = Tnew
    {           ( AllocOp NewOp,    [_1] )}
| _1 = Tdelete
    {           ( AllocOp DeleteOp, [_1] )}
| _1 = Tnew _2 = TOCro_new _3 = TCCro_new
    {                               ( AllocOp NewArrayOp,    [_1;_2;_3] )}
| _1 = Tdelete _2 = TOCro_new _3 = TCCro_new
    {                               ( AllocOp DeleteArrayOp, [_1;_2;_3] )}

qualified_id:
  _1 = nested_name_specifier _2 = unqualified_id
    {   ( _1, _2 )}

nested_name_specifier:
  _1 = class_or_namespace_name_for_qualifier _2 = TColCol _3 = nested_name_specifier_opt
    {   ( (_1, _2)::_3 )}

class_or_namespace_name_for_qualifier:
  _1 = TIdent_ClassnameInQualifier
    {     ( QClassname _1 )}
| _1 = TIdent_TemplatenameInQualifier _2 = TInf_Template _3 = template_argument_list _4 = TSup_Template
    {     ( QTemplateId (_1, (_2, _3, _4)) )}

enum_name_or_typedef_name_or_simple_class_name:
  _1 = TIdent_Typedef
    {                  ( _1 )}

namespace_name:
  _1 = TIdent
    {          ( _1 )}

nested_name_specifier2:
  _1 = class_or_namespace_name_for_qualifier2 _2 = TColCol_BeforeTypedef _3 = nested_name_specifier_opt2
    {     ( (_1, _2)::_3 )}

class_or_namespace_name_for_qualifier2:
  _1 = TIdent_ClassnameInQualifier_BeforeTypedef
    {     ( QClassname _1  )}
| _1 = TIdent_TemplatenameInQualifier_BeforeTypedef _2 = TInf_Template _3 = template_argument_list _4 = TSup_Template
    {     ( QTemplateId (_1, (_2, _3, _4)) )}

ident:
  _1 = TIdent
    {                  ( _1 )}
| _1 = TIdent_Typedef
    {                  ( _1 )}

expr:
  _1 = assign_expr
    {                           ( _1 )}
| _1 = expr _2 = TComma _3 = assign_expr
    {                           ( mk_e (Sequence (_1,_3)) [_2] )}

assign_expr:
  _1 = cond_expr
    {                                 ( _1 )}
| _1 = cast_expr _2 = TAssign _3 = assign_expr
    {                                 ( mk_e(Assignment (_1,fst _2,_3)) [snd _2])}
| _1 = cast_expr _2 = TEq _3 = assign_expr
    {                                 ( mk_e(Assignment (_1,SimpleAssign,_3)) [_2])}
| _1 = Tthrow _2 = assign_expr_opt
    {                                 ( mk_e (Throw _2) [_1] )}

cond_expr:
  _1 = arith_expr
    {                ( _1 )}
| _1 = arith_expr _2 = TWhy _3 = expr_opt _4 = TCol _5 = assign_expr
    {     ( mk_e (CondExpr (_1,_3,_5)) [_2;_4] )}

arith_expr:
  _1 = pm_expr
    {                               ( _1 )}
| _1 = arith_expr _2 = TMul _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Mul,      _3)) [_2] )}
| _1 = arith_expr _2 = TDiv _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Div,      _3)) [_2] )}
| _1 = arith_expr _2 = TMod _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Mod,      _3)) [_2] )}
| _1 = arith_expr _2 = TPlus _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Plus,     _3)) [_2] )}
| _1 = arith_expr _2 = TMinus _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Minus,    _3)) [_2] )}
| _1 = arith_expr _2 = TShl _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith DecLeft,  _3)) [_2] )}
| _1 = arith_expr _2 = TShr _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith DecRight, _3)) [_2] )}
| _1 = arith_expr _2 = TInf _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical Inf,    _3)) [_2] )}
| _1 = arith_expr _2 = TSup _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical Sup,    _3)) [_2] )}
| _1 = arith_expr _2 = TInfEq _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical InfEq,  _3)) [_2] )}
| _1 = arith_expr _2 = TSupEq _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical SupEq,  _3)) [_2] )}
| _1 = arith_expr _2 = TEqEq _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical Eq,     _3)) [_2] )}
| _1 = arith_expr _2 = TNotEq _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical NotEq,  _3)) [_2] )}
| _1 = arith_expr _2 = TAnd _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith And,      _3)) [_2] )}
| _1 = arith_expr _2 = TOr _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Or,       _3)) [_2] )}
| _1 = arith_expr _2 = TXor _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Arith Xor,      _3)) [_2] )}
| _1 = arith_expr _2 = TAndLog _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical AndLog, _3)) [_2] )}
| _1 = arith_expr _2 = TOrLog _3 = arith_expr
    {                                 ( mk_e(Binary (_1, Logical OrLog,  _3)) [_2] )}

pm_expr:
  _1 = cast_expr
    {             ( _1 )}
| _1 = pm_expr _2 = TDotStar _3 = cast_expr
    {     ( mk_e(RecordStarAccess   (_1,_3)) [_2])}
| _1 = pm_expr _2 = TPtrOpStar _3 = cast_expr
    {     ( mk_e(RecordPtStarAccess (_1,_3)) [_2])}

cast_expr:
  _1 = unary_expr
    {                                     ( _1 )}
| _1 = TOPar _2 = type_id _3 = TCPar _4 = cast_expr
    {                                 ( mk_e(Cast ((_1, _2, _3), _4)) noii )}

unary_expr:
  _1 = postfix_expr
    {                                   ( _1 )}
| _1 = TInc _2 = unary_expr
    {                                   ( mk_e(Infix (_2, Inc))    [_1] )}
| _1 = TDec _2 = unary_expr
    {                                   ( mk_e(Infix (_2, Dec))    [_1] )}
| _1 = unary_op _2 = cast_expr
    {                                   ( mk_e(Unary (_2, fst _1)) [snd _1] )}
| _1 = Tsizeof _2 = unary_expr
    {                                   ( mk_e(SizeOfExpr (_1, _2)) noii )}
| _1 = Tsizeof _2 = TOPar _3 = type_id _4 = TCPar
    {                               ( mk_e(SizeOfType (_1, (_2, _3, _4))) noii )}
| _1 = new_expr
    {                 ( _1 )}
| _1 = delete_expr
    {                 ( _1 )}

unary_op:
  _1 = TAnd
    {          ( GetRef,     _1 )}
| _1 = TMul
    {          ( DeRef,      _1 )}
| _1 = TPlus
    {          ( UnPlus,     _1 )}
| _1 = TMinus
    {          ( UnMinus,    _1 )}
| _1 = TTilde
    {          ( Tilde,      _1 )}
| _1 = TBang
    {          ( Not,        _1 )}
| _1 = TAndLog
    {           ( GetRefLabel, _1 )}

postfix_expr:
  _1 = primary_expr
    {                              ( _1 )}
| _1 = postfix_expr _2 = TOCro _3 = expr _4 = TCCro
    {     ( mk_e(ArrayAccess (_1, (_2, _3, _4))) noii )}
| _1 = postfix_expr _2 = TOPar _3 = argument_list_opt _4 = TCPar
    {     ( mk_e(mk_funcall _1 (_2, _3, _4)) noii )}
| _1 = postfix_expr _2 = TDot _3 = template_opt _4 = tcolcol_opt _5 = id_expression
    {     ( let name = (_4, fst _5, snd _5) in mk_e(RecordAccess (_1,name)) [_2] )}
| _1 = postfix_expr _2 = TPtrOp _3 = template_opt _4 = tcolcol_opt _5 = id_expression
    {     ( let name = (_4, fst _5, snd _5) in mk_e(RecordPtAccess(_1,name)) [_2] )}
| _1 = postfix_expr _2 = TInc
    {                              ( mk_e(Postfix (_1, Inc)) [_2] )}
| _1 = postfix_expr _2 = TDec
    {                              ( mk_e(Postfix (_1, Dec)) [_2] )}
| _1 = compound_literal_expr
    {                         ( _1 )}
| _1 = cast_operator_expr
    {                      ( _1 )}
| _1 = Ttypeid _2 = TOPar _3 = unary_expr _4 = TCPar
    {                                  ( mk_e(TypeId (_1, (_2, Right _3, _4))) noii )}
| _1 = Ttypeid _2 = TOPar _3 = type_id _4 = TCPar
    {                                  ( mk_e(TypeId (_1, (_2, Left _3, _4))) noii )}
| _1 = cast_constructor_expr
    {                         ( _1 )}

primary_expr:
  _1 = TInt
    {           ( mk_e(C (Int    (fst _1))) [snd _1] )}
| _1 = TFloat
    {           ( mk_e(C (Float  (fst _1))) [snd _1] )}
| _1 = TString
    {           ( mk_e(C (String (fst _1))) [snd _1] )}
| _1 = TChar
    {           ( mk_e(C (Char   (fst _1))) [snd _1] )}
| _1 = Ttrue
    {           ( mk_e(C (Bool false)) [_1] )}
| _1 = Tfalse
    {           ( mk_e(C (Bool false)) [_1] )}
| _1 = TOPar _2 = expr _3 = TCPar
    {                    ( mk_e(ParenExpr (_1, _2, _3)) noii )}
| _1 = string_elem _2 = string_list
    {                           ( mk_e(C (MultiString)) (_1 @ _2) )}
| _1 = TOPar _2 = compound _3 = TCPar
    {                           ( mk_e(StatementExpr (_1, _2, _3)) noii )}
| _1 = Tthis
    {         ( mk_e(This _1) [] )}
| _1 = primary_cplusplus_id
    {                        ( _1 )}

primary_cplusplus_id:
  _1 = id_expression
    {     ( let name = (None, fst _1, snd _1) in
       mk_e (Id (name, noIdInfo())) []  )}
| _1 = TColCol _2 = TIdent
    {     ( let name = Some _1, noQscope, IdIdent _2 in
       mk_e (Id (name, noIdInfo())) [] )}
| _1 = TColCol _2 = operator_function_id
    {     ( let qop = _2 in
       let name = (Some _1, noQscope, qop) in
       mk_e (Id (name, noIdInfo())) [] )}
| _1 = TColCol _2 = qualified_id
    {     ( let name = (Some _1, fst _2, snd _2) in
       mk_e (Id (name, noIdInfo())) [] )}

cast_operator_expr:
  _1 = cpp_cast_operator _2 = TInf_Template _3 = type_id _4 = TSup_Template _5 = TOPar _6 = expr _7 = TCPar
    {     ( mk_e (CplusplusCast (_1, (_2, _3, _4), (_5, _6, _7))) noii )}
| _1 = cpp_cast_operator _2 = TOPar _3 = expr _4 = TCPar
    {     ( mk_e ExprTodo noii )}

cpp_cast_operator:
  _1 = Tstatic_cast
    {                     ( Static_cast, _1 )}
| _1 = Tdynamic_cast
    {                     ( Dynamic_cast, _1 )}
| _1 = Tconst_cast
    {                     ( Const_cast, _1 )}
| _1 = Treinterpret_cast
    {                     ( Reinterpret_cast, _1 )}

cast_constructor_expr:
  _1 = TIdent_TypedefConstr _2 = TOPar _3 = argument_list_opt _4 = TCPar
    {     ( let name = None, noQscope, IdIdent _1 in
       let ft = nQ, (TypeName name, noii) in
       mk_e(ConstructedObject (ft, (_2, _3, _4))) noii
     )}
| _1 = basic_type_2 _2 = TOPar _3 = argument_list_opt _4 = TCPar
    {     ( let ft = nQ, _1 in
       mk_e(ConstructedObject (ft, (_2, _3, _4))) noii
     )}

new_expr:
  _1 = tcolcol_opt _2 = Tnew _3 = new_placement_opt _4 = new_type_id _5 = new_initializer_opt
    {     ( mk_e (New (_1, _2, _3, _4, _5)) noii  )}

delete_expr:
  _1 = tcolcol_opt _2 = Tdelete _3 = cast_expr
    {     ( mk_e (Delete (_1, _3)) [_2] )}
| _1 = tcolcol_opt _2 = Tdelete _3 = TOCro_new _4 = TCCro_new _5 = cast_expr
    {     ( mk_e (DeleteArray (_1, _5)) [_2;_3;_4] )}

new_placement:
  _1 = TOPar _2 = argument_list _3 = TCPar
    {                             ( (_1, _2, _3) )}

new_initializer:
  _1 = TOPar _2 = argument_list_opt _3 = TCPar
    {                                 ( (_1, _2, _3) )}

compound_literal_expr:
  _1 = TOPar _2 = type_id _3 = TCPar _4 = TOBrace _5 = TCBrace
    {     ( mk_e(GccConstructor ((_1, _2, _3), (_4, [], _5))) noii )}
| _1 = TOPar _2 = type_id _3 = TCPar _4 = TOBrace _5 = initialize_list _6 = gcc_comma_opt _7 = TCBrace
    {     ( mk_e(GccConstructor ((_1, _2, _3), (_4, List.rev _5, _7))) noii )}

string_elem:
  _1 = TString
    {           ( [snd _1] )}
| _1 = TIdent_MacroString
    {                      ( [_1] )}

argument:
  _1 = assign_expr
    {               ( Left _1 )}
| _1 = type_id
    {           ( Right (ArgType _1)  )}

const_expr:
  _1 = cond_expr
    {                      ( _1  )}

basic_type_2:
  _1 = Tchar_Constr
    {                   ( (BaseType (IntType CChar)), [_1])}
| _1 = Tint_Constr
    {                   ( (BaseType (IntType (Si (Signed,CInt)))), [_1])}
| _1 = Tfloat_Constr
    {                   ( (BaseType (FloatType CFloat)),  [_1])}
| _1 = Tdouble_Constr
    {                   ( (BaseType (FloatType CDouble)), [_1] )}
| _1 = Twchar_t_Constr
    {                   ( (BaseType (IntType WChar_t)),         [_1] )}
| _1 = Tshort_Constr
    {                   ( (BaseType (IntType (Si (Signed, CShort)))),  [_1] )}
| _1 = Tlong_Constr
    {                   ( (BaseType (IntType (Si (Signed, CLong)))),   [_1] )}
| _1 = Tbool_Constr
    {                   ( (BaseType (IntType CBool)),         [_1] )}

statement:
  _1 = compound
    {                   ( Compound _1, noii )}
| _1 = expr_statement
    {                   ( ExprStatement(fst _1), snd _1 )}
| _1 = labeled
    {                   ( Labeled      (fst _1), snd _1 )}
| _1 = selection
    {                   ( Selection    (fst _1), snd _1 )}
| _1 = iteration
    {                   ( Iteration    (fst _1), snd _1 )}
| _1 = jump _2 = TPtVirg
    {                   ( Jump         (fst _1), snd _1 @ [_2] )}
| _1 = TIdent_MacroStmt
    {                    ( MacroStmt, [_1] )}
| _1 = declaration_statement
    {                         ( _1 )}
| _1 = function_definition
    {                       ( NestedFunc _1, noii )}
| _1 = try_block
    {             ( _1 )}

compound:
  _1 = TOBrace _2 = statement_list_opt _3 = TCBrace
    {                                      ( (_1, _2, _3) )}

expr_statement:
  _1 = expr_opt _2 = TPtVirg
    {                    ( _1, [_2] )}

labeled:
  _1 = ident _2 = TCol _3 = statement
    {                                     ( Label (fst _1, _3),  [snd _1; _2] )}
| _1 = Tcase _2 = const_expr _3 = TCol _4 = statement
    {                                     ( Case (_2, _4),       [_1; _3] )}
| _1 = Tcase _2 = const_expr _3 = TEllipsis _4 = const_expr _5 = TCol _6 = statement
    {     ( CaseRange (_2, _4, _6), [_1;_3;_5] )}
| _1 = Tdefault _2 = TCol _3 = statement
    {                                     ( Default _3,             [_1; _2] )}

selection:
  _1 = Tif _2 = TOPar _3 = expr _4 = TCPar _5 = statement %prec LOW_PRIORITY_RULE
    {     ( If (_1, (_2, _3, _4), _5, None, (ExprStatement None, [])), noii )}
| _1 = Tif _2 = TOPar _3 = expr _4 = TCPar _5 = statement _6 = Telse _7 = statement
    {     ( If (_1, (_2, _3, _4), _5, Some _6, _7), noii )}
| _1 = Tswitch _2 = TOPar _3 = expr _4 = TCPar _5 = statement
    {     ( Switch (_1, (_2, _3, _4), _5), noii )}

iteration:
  _1 = Twhile _2 = TOPar _3 = expr _4 = TCPar _5 = statement
    {     ( While (_1, (_2, _3, _4), _5), noii )}
| _1 = Tdo _2 = statement _3 = Twhile _4 = TOPar _5 = expr _6 = TCPar _7 = TPtVirg
    {     ( DoWhile (_1, _2, _3, (_4, _5, _6), _7), noii )}
| _1 = Tfor _2 = TOPar _3 = expr_statement _4 = expr_statement _5 = expr_opt _6 = TCPar _7 = statement
    {     ( For (_1, (_2, (_3,_4, (_5, [])), _6), _7), noii )}
| _1 = TIdent_MacroIterator _2 = TOPar _3 = argument_list_opt _4 = TCPar _5 = statement
    {     ( MacroIteration (_1, (_2, _3, _4), _5), noii )}

jump:
  _1 = Tgoto _2 = ident
    {                ( Goto (fst _2),  [_1;snd _2] )}
| _1 = Tcontinue
    {                ( Continue,       [_1] )}
| _1 = Tbreak
    {                ( Break,          [_1] )}
| _1 = Treturn
    {                ( Return,         [_1] )}
| _1 = Treturn _2 = expr
    {                ( ReturnExpr _2,  [_1] )}
| _1 = Tgoto _2 = TMul _3 = expr
    {                   ( GotoComputed _3, [_1;_2] )}

statement_list_opt:
  
    {                 ( [] )}
| _1 = statement_list
    {                  ( _1 )}

statement_list:
  _1 = statement_seq
    {                 ( [_1] )}
| _1 = statement_list _2 = statement_seq
    {                                ( _1 @ [_2] )}

statement_seq:
  _1 = statement
    {             ( StmtElem _1 )}
| _1 = cpp_directive
    {     ( CppDirectiveStmt _1 )}
| _1 = cpp_ifdef_directive
    {     ( IfdefStmt _1 )}

declaration_statement:
  _1 = block_declaration
    {                     ( DeclStmt _1, noii )}

try_block:
  _1 = Ttry _2 = compound _3 = handler_list
    {                              ( Try (_1, _2, _3), noii )}

handler:
  _1 = Tcatch _2 = TOPar _3 = exception_decl _4 = TCPar _5 = compound
    {                                              ( (_1, (_2, _3, _4), _5) )}

exception_decl:
  _1 = parameter_decl
    {                  ( ExnDecl _1 )}
| _1 = TEllipsis
    {                  ( ExnDeclEllipsis _1 )}

type_spec:
  _1 = simple_type_specifier
    {                         ( _1 )}
| _1 = elaborated_type_specifier
    {                             ( _1 )}
| _1 = enum_specifier
    {                   ( Right3 _1, noii )}
| _1 = class_specifier
    {                   ( Right3 (StructDef _1), noii )}

simple_type_specifier:
  _1 = Tvoid
    {                        ( Right3 (BaseType Void),            [_1] )}
| _1 = Tchar
    {                        ( Right3 (BaseType (IntType CChar)), [_1])}
| _1 = Tint
    {                        ( Right3 (BaseType (IntType (Si (Signed,CInt)))), [_1])}
| _1 = Tfloat
    {                        ( Right3 (BaseType (FloatType CFloat)),  [_1])}
| _1 = Tdouble
    {                        ( Right3 (BaseType (FloatType CDouble)), [_1] )}
| _1 = Tshort
    {                        ( Middle3 Short,  [_1])}
| _1 = Tlong
    {                        ( Middle3 Long,   [_1])}
| _1 = Tsigned
    {                        ( Left3 Signed,   [_1])}
| _1 = Tunsigned
    {                        ( Left3 UnSigned, [_1])}
| _1 = Tbool
    {                        ( Right3 (BaseType (IntType CBool)),            [_1] )}
| _1 = Twchar_t
    {                        ( Right3 (BaseType (IntType WChar_t)),         [_1] )}
| _1 = Ttypeof _2 = TOPar _3 = assign_expr _4 = TCPar
    {                                   ( Right3 (TypeOf (_1,(_2,Right _3,_4))),noii)}
| _1 = Ttypeof _2 = TOPar _3 = type_id _4 = TCPar
    {                                   ( Right3 (TypeOf (_1,(_2,Left _3,_4))),noii)}
| _1 = type_cplusplus_id
    {                     ( Right3 (TypeName _1), noii )}

elaborated_type_specifier:
  _1 = Tenum _2 = ident
    {     ( Right3 (EnumName (_1, _2)), noii )}
| _1 = class_key _2 = ident
    {     ( Right3 (StructUnionName (_1, _2)), noii )}
| _1 = Ttypename _2 = type_cplusplus_id
    {     ( Right3 (TypenameKwd (_1, _2)), noii )}

type_cplusplus_id:
  _1 = type_name
    {                                    ( None, noQscope, _1 )}
| _1 = nested_name_specifier2 _2 = type_name
    {                                    ( None, _1, _2 )}
| _1 = TColCol_BeforeTypedef _2 = type_name
    {                                    ( Some _1, noQscope, _2 )}
| _1 = TColCol_BeforeTypedef _2 = nested_name_specifier2 _3 = type_name
    {     ( Some _1, _2, _3 )}

type_name:
  _1 = enum_name_or_typedef_name_or_simple_class_name
    {                                                  ( IdIdent _1 )}
| _1 = template_id
    {               ( _1 )}

template_id:
  _1 = TIdent_Templatename _2 = TInf_Template _3 = template_argument_list _4 = TSup_Template
    {    ( IdTemplateId (_1, (_2, _3, _4)) )}

template_argument:
  _1 = type_id
    {               ( Left _1 )}
| _1 = assign_expr
    {               ( Right _1 )}

cv_qualif:
  _1 = Tconst
    {             ( {const=Some _1; volatile=None} )}
| _1 = Tvolatile
    {             ( {const=None ; volatile=Some _1} )}
| _1 = Trestrict
    {             ( (* TODO *) {const=None ; volatile=None} )}

declarator:
  _1 = pointer _2 = direct_d
    {                    ( (fst _2, fun x -> x +> _1 +> (snd _2)  ) )}
| _1 = direct_d
    {                    ( _1  )}

pointer:
  _1 = TMul
    {                               ( fun x ->(nQ,         (Pointer x,     [_1])))}
| _1 = TMul _2 = cv_qualif_list
    {                               ( fun x ->(_2.qualifD, (Pointer x,     [_1])))}
| _1 = TMul _2 = pointer
    {                               ( fun x ->(nQ,         (Pointer (_2 x),[_1])))}
| _1 = TMul _2 = cv_qualif_list _3 = pointer
    {                               ( fun x ->(_2.qualifD, (Pointer (_3 x),[_1])))}
| _1 = TAnd
    {                               ( fun x ->(nQ,    (Reference x,    [_1])))}
| _1 = TAnd _2 = pointer
    {                               ( fun x ->(nQ,    (Reference (_2 x),[_1])))}

direct_d:
  _1 = declarator_id
    {     ( (_1, fun x -> x) )}
| _1 = TOPar _2 = declarator _3 = TCPar
    {     ( (fst _2, fun x -> (nQ, (ParenType (_1, (snd _2) x, _3), noii))) )}
| _1 = direct_d _2 = TOCro _3 = TCCro
    {     ( (fst _1, fun x->(snd _1) (nQ,(Array ((_2,None,_3),x), noii))) )}
| _1 = direct_d _2 = TOCro _3 = const_expr _4 = TCCro
    {     ( (fst _1, fun x->(snd _1) (nQ,(Array ((_2, Some _3, _4),x),noii))) )}
| _1 = direct_d _2 = TOPar _3 = TCPar _4 = const_opt _5 = exn_spec_opt
    {     ( (fst _1, fun x-> (snd _1)
         (nQ, (FunctionType {
           ft_ret= x; ft_params = (_2, [], _3);
           ft_dots = None; ft_const = _4; ft_throw = _5; }, noii)))
     )}
| _1 = direct_d _2 = TOPar _3 = parameter_type_list _4 = TCPar _5 = const_opt _6 = exn_spec_opt
    {     ( (fst _1, fun x-> (snd _1)
          (nQ,(FunctionType {
            ft_ret = x; ft_params = (_2,fst _3,_4);
            ft_dots = snd _3; ft_const = _5; ft_throw = _6; }, noii)))
     )}

declarator_id:
  _1 = tcolcol_opt _2 = id_expression
    {     ( (_1, fst _2, snd _2) )}

abstract_declarator:
  _1 = pointer
    {                                      ( _1 )}
| _1 = direct_abstract_declarator
    {                                      ( _1 )}
| _1 = pointer _2 = direct_abstract_declarator
    {                                      ( fun x -> x +> _2 +> _1 )}

direct_abstract_declarator:
  _1 = TOPar _2 = abstract_declarator _3 = TCPar
    {     ( (fun x -> (nQ, (ParenType (_1, _2 x, _3), noii))) )}
| _1 = TOCro _2 = TCCro
    {     ( fun x ->   (nQ, (Array ((_1,None, _2), x), noii)))}
| _1 = TOCro _2 = const_expr _3 = TCCro
    {     ( fun x ->   (nQ, (Array ((_1, Some _2, _3), x), noii)))}
| _1 = direct_abstract_declarator _2 = TOCro _3 = TCCro
    {     ( fun x ->_1 (nQ, (Array ((_2, None, _3), x), noii)) )}
| _1 = direct_abstract_declarator _2 = TOCro _3 = const_expr _4 = TCCro
    {     ( fun x ->_1 (nQ, (Array ((_2, Some _3, _4), x), noii)) )}
| _1 = TOPar _2 = TCPar
    {     ( fun x -> (nQ, (FunctionType {
       ft_ret = x; ft_params = (_1,[],_2);
       ft_dots = None; ft_const = None; ft_throw = None;}, noii)) )}
| _1 = TOPar _2 = parameter_type_list _3 = TCPar
    {     ( fun x -> (nQ, (FunctionType {
         ft_ret = x; ft_params = (_1,fst _2,_3);
         ft_dots = snd _2; ft_const = None; ft_throw = None; }, noii)) )}
| _1 = direct_abstract_declarator _2 = TOPar _3 = TCPar _4 = const_opt _5 = exn_spec_opt
    {     ( fun x -> _1 (nQ, (FunctionType {
         ft_ret = x; ft_params = (_2,[],_3);
         ft_dots = None; ft_const = _4; ft_throw = _5; }, noii)) )}
| _1 = direct_abstract_declarator _2 = TOPar _3 = parameter_type_list _4 = TCPar _5 = const_opt _6 = exn_spec_opt
    {     ( fun x -> _1 (nQ, (FunctionType {
         ft_ret = x; ft_params = (_2,fst _3,_4);
         ft_dots = snd _3; ft_const = _5; ft_throw = _6; }, noii)) )}

parameter_type_list:
  _1 = parameter_list
    {                                   ( _1, None )}
| _1 = parameter_list _2 = TComma _3 = TEllipsis
    {                                   ( _1, Some (_2,_3) )}

parameter_decl:
  _1 = decl_spec _2 = declarator
    {     ( let (t_ret,reg) = type_and_register_from_decl _1 in
       let (name, ftyp) = fixNameForParam _2 in
       { p_name = Some name; p_type = ftyp t_ret;
         p_register = reg; p_val = None } )}
| _1 = decl_spec _2 = abstract_declarator
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = _2 t_ret;
         p_register = reg; p_val = None } )}
| _1 = decl_spec
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = t_ret; p_register = reg; p_val = None } )}
| _1 = decl_spec _2 = declarator _3 = TEq _4 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       let (name, ftyp) = fixNameForParam _2 in
       { p_name = Some name; p_type = ftyp t_ret;
         p_register = reg; p_val = Some (_3, _4) } )}
| _1 = decl_spec _2 = abstract_declarator _3 = TEq _4 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = _2 t_ret;
         p_register = reg; p_val = Some (_3, _4) } )}
| _1 = decl_spec _2 = TEq _3 = assign_expr
    {     ( let (t_ret, reg) = type_and_register_from_decl _1 in
       { p_name = None; p_type = t_ret;
         p_register = reg; p_val = Some(_2,_3) } )}

parameter_list:
  _1 = parameter_decl2
    {                                         ( [_1, []] )}
| _1 = parameter_list _2 = TComma _3 = parameter_decl2
    {                                         ( _1 @ [_3,  [_2]] )}

parameter_decl2:
  _1 = parameter_decl
    {                  ( _1 )}
| _1 = TIdent
    {     (
       let t = nQ, (TypeName (None, [], IdIdent _1), noii) in
       { p_name = None; p_type = t; p_val = None; p_register = None; }
     )}

exception_specification:
  _1 = Tthrow _2 = TOPar _3 = TCPar
    {                      ( (_1, (_2, [], _3)) )}
| _1 = Tthrow _2 = TOPar _3 = exn_name _4 = TCPar
    {                               ( (_1, (_2, [Left _3], _4)) )}
| _1 = Tthrow _2 = TOPar _3 = exn_name _4 = TComma _5 = exn_name _6 = TCPar
    {     ( (_1, (_2, [Left _3; Right _4; Left _5], _6))  )}

exn_name:
  _1 = ident
    {     ( None, [], IdIdent _1 )}

const_opt:
  _1 = Tconst
    {                 ( Some _1 )}
| 
    {                 ( None )}

spec_qualif_list:
  _1 = type_spec
    {                                ( addTypeD _1 nullDecl )}
| _1 = cv_qualif
    {                                ( {nullDecl with qualifD = _1} )}
| _1 = type_spec _2 = spec_qualif_list
    {                                ( addTypeD _1 _2   )}
| _1 = cv_qualif _2 = spec_qualif_list
    {                                ( addQualifD _1 _2 )}

cv_qualif_list:
  _1 = cv_qualif
    {                              ( {nullDecl with qualifD = _1 } )}
| _1 = cv_qualif_list _2 = cv_qualif
    {                              ( addQualifD _2 _1 )}

type_id:
  _1 = spec_qualif_list
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in  t_ret )}
| _1 = spec_qualif_list _2 = abstract_declarator
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in _2 t_ret )}

new_type_id:
  _1 = spec_qualif_list %prec LOW_PRIORITY_RULE
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in  t_ret )}
| _1 = spec_qualif_list _2 = new_declarator
    {     ( let (t_ret, _, _) = type_and_storage_from_decl _1 in (* TODOAST *) t_ret )}

new_declarator:
  _1 = ptr_operator _2 = new_declarator
    {     ( () )}
| _1 = ptr_operator %prec LOW_PRIORITY_RULE
    {     ( () )}
| _1 = direct_new_declarator
    {     ( () )}

ptr_operator:
  _1 = TMul
    {        ( () )}
| _1 = TAnd
    {        ( () )}

direct_new_declarator:
  _1 = TOCro _2 = expr _3 = TCCro
    {                    ( () )}
| _1 = direct_new_declarator _2 = TOCro _3 = expr _4 = TCCro
    {                                          ( () )}

conversion_type_id:
  _1 = simple_type_specifier _2 = conversion_declarator
    {     ( let tx = addTypeD _1 nullDecl in
       let (t_ret, _, _) = type_and_storage_from_decl tx in t_ret
     )}
| _1 = simple_type_specifier %prec LOW_PRIORITY_RULE
    {     ( let tx = addTypeD _1 nullDecl in
       let (t_ret, _, _) = type_and_storage_from_decl tx in t_ret
     )}

conversion_declarator:
  _1 = ptr_operator _2 = conversion_declarator
    {     ( () )}
| _1 = ptr_operator %prec LOW_PRIORITY_RULE
    {     ( () )}

class_specifier:
  _1 = class_head _2 = TOBrace _3 = member_specification_opt _4 = TCBrace
    {     ( let (kind, nameopt, baseopt) = _1 in
       { c_kind = kind; c_name = nameopt;
         c_inherit = baseopt; c_members = (_2, _3, _4) } )}

class_head:
  _1 = class_key
    {     ( _1, None, None )}
| _1 = class_key _2 = ident _3 = base_clause_opt
    {     ( let name = None, noQscope, IdIdent _2 in
       _1, Some name, _3 )}
| _1 = class_key _2 = nested_name_specifier _3 = ident _4 = base_clause_opt
    {     ( let name = None, _2, IdIdent _3 in
       _1, Some name, _4 )}

class_key:
  _1 = Tstruct
    {             ( Struct, _1 )}
| _1 = Tunion
    {             ( Union, _1 )}
| _1 = Tclass
    {             ( Class, _1 )}

base_clause:
  _1 = TCol _2 = base_specifier_list
    {                            ( _1, _2 )}

base_specifier:
  _1 = class_name
    {     ( { i_name = _1; i_virtual = None; i_access = None } )}
| _1 = access_specifier _2 = class_name
    {     ( { i_name = _2; i_virtual = None; i_access = Some _1 } )}
| _1 = Tvirtual _2 = access_specifier _3 = class_name
    {     ( { i_name = _3; i_virtual = Some _1; i_access = Some _2 } )}

class_name:
  _1 = type_cplusplus_id
    {                      ( _1 )}
| _1 = TIdent
    {                      ( None, noQscope, IdIdent _1 )}

member_specification:
  _1 = member_declaration _2 = member_specification_opt
    {     ( ClassElem _1::_2 )}
| _1 = access_specifier _2 = TCol _3 = member_specification_opt
    {     ( ClassElem (Access (_1, _2))::_3 )}

access_specifier:
  _1 = Tpublic
    {              ( Public, _1 )}
| _1 = Tprivate
    {              ( Private, _1 )}
| _1 = Tprotected
    {              ( Protected, _1 )}

member_declaration:
  _1 = field_declaration
    {                          ( fixFieldOrMethodDecl _1 )}
| _1 = function_definition
    {                          ( MemberFunc (FunctionOrMethod _1) )}
| _1 = qualified_id _2 = TPtVirg
    {     ( let name = (None, fst _1, snd _1) in
       QualifiedIdInClass (name, _2)
     )}
| _1 = using_declaration
    {                          ( UsingDeclInClass _1 )}
| _1 = template_declaration
    {                          ( TemplateDeclInClass _1 )}
| _1 = ctor_dtor_member
    {                          ( _1 )}
| _1 = TPtVirg
    {              ( EmptyField _1 )}

field_declaration:
  _1 = decl_spec _2 = TPtVirg
    {     ( (* gccext: allow empty elements if it is a structdef or enumdef *)
       let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       let onedecl = { v_namei = None; v_type = t_ret; v_storage = sto } in
       ([(FieldDecl onedecl),noii], _2)
     )}
| _1 = decl_spec _2 = member_declarator_list _3 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       (_2 +> (List.map (fun (f, iivirg) -> f t_ret sto, iivirg)), _3)
     )}

member_declarator:
  _1 = declarator
    {     ( let (name, partialt) = _1 in (fun t_ret sto ->
       FieldDecl {
         v_namei = Some (name, None);
         v_type = partialt t_ret; v_storage = sto; })
     )}
| _1 = declarator _2 = TEq _3 = const_expr
    {     ( let (name, partialt) = _1 in (fun t_ret sto ->
       FieldDecl {
         v_namei = Some (name, Some (EqInit (_2, InitExpr _3)));
         v_type = partialt t_ret; v_storage = sto;
       })
     )}
| _1 = declarator _2 = TCol _3 = const_expr
    {     ( let (name, _partialt) = fixNameForParam _1 in (fun t_ret _stoTODO ->
       BitField (Some name, _2, t_ret, _3))
     )}
| _1 = TCol _2 = const_expr
    {     ( (fun t_ret _stoTODO -> BitField (None, _1, t_ret, _2)) )}

ctor_dtor_member:
  _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = parameter_type_list_opt _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( MemberFunc (Constructor (mk_constructor _2 (_3, _4, _5) _7)) )}
| _1 = ctor_spec _2 = TIdent_Constructor _3 = TOPar _4 = parameter_type_list_opt _5 = TCPar _6 = TPtVirg
    {     ( MemberDecl (ConstructorDecl (_2, (_3, opt_to_list_params _4, _5), _6)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = void_opt _6 = TCPar _7 = exn_spec_opt _8 = compound
    {     ( MemberFunc (Destructor (mk_destructor _2 _3 (_4, _5, _6) _7 _8)) )}
| _1 = dtor_spec _2 = TTilde _3 = ident _4 = TOPar _5 = void_opt _6 = TCPar _7 = exn_spec_opt _8 = TPtVirg
    {     ( MemberDecl (DestructorDecl (_2, _3, (_4, _5, _6), _7, _8)) )}

ctor_spec:
  _1 = Texplicit
    {             ( )}
| _1 = Tinline
    {           ( )}
| 
    {                 ( )}

dtor_spec:
  _1 = Tvirtual
    {            ( )}
| _1 = Tinline
    {           ( )}
| 
    {                 ( )}

ctor_mem_initializer_list_opt:
  _1 = TCol _2 = mem_initializer_list
    {                             ( () )}
| 
    {                   ( () )}

mem_initializer:
  _1 = mem_initializer_id _2 = TOPar _3 = argument_list_opt _4 = TCPar
    {                                                    ( () )}

mem_initializer_id:
  _1 = primary_cplusplus_id
    {                        ( () )}

enum_specifier:
  _1 = Tenum _2 = TOBrace _3 = enumerator_list _4 = gcc_comma_opt _5 = TCBrace
    {     ( EnumDef (_1, None, (_2, _3, _5)) (*$4*) )}
| _1 = Tenum _2 = ident _3 = TOBrace _4 = enumerator_list _5 = gcc_comma_opt _6 = TCBrace
    {     ( EnumDef (_1, Some _2, (_3, _4, _6)) (*$5*) )}

enumerator:
  _1 = ident
    {                        ( { e_name = _1; e_val = None; } )}
| _1 = ident _2 = TEq _3 = const_expr
    {                        ( { e_name = _1; e_val = Some (_2, _3); } )}

simple_declaration:
  _1 = decl_spec _2 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       DeclList ([{v_namei = None; v_type = t_ret; v_storage = sto},noii],_2)
     )}
| _1 = decl_spec _2 = init_declarator_list _3 = TPtVirg
    {     ( let (t_ret, sto, _inline) = type_and_storage_from_decl _1 in
       DeclList (
         (_2 +> List.map (fun (((name, f), iniopt), iivirg) ->
           (* old: if fst (unwrap storage)=StoTypedef then LP.add_typedef s; *)
           { v_namei = Some (name, iniopt);
             v_type = f t_ret; v_storage = sto
           },
           iivirg
         )), _3)
     )}
| _1 = TIdent_MacroDecl _2 = TOPar _3 = argument_list _4 = TCPar _5 = TPtVirg
    {     ( MacroDecl ([], _1, (_2, _3, _4), _5) )}
| _1 = Tstatic _2 = TIdent_MacroDecl _3 = TOPar _4 = argument_list _5 = TCPar _6 = TPtVirg
    {     ( MacroDecl ([_1], _2, (_3, _4, _5), _6) )}
| _1 = Tstatic _2 = Tconst_MacroDeclConst _3 = TIdent_MacroDecl _4 = TOPar _5 = argument_list _6 = TCPar _7 = TPtVirg
    {     ( MacroDecl ([_1;_2], _3, (_4, _5, _6), _7) )}

decl_spec:
  _1 = storage_class_spec
    {                           ( {nullDecl with storageD = _1 } )}
| _1 = type_spec
    {                           ( addTypeD _1 nullDecl )}
| _1 = cv_qualif
    {                           ( {nullDecl with qualifD  = _1 } )}
| _1 = function_spec
    {                           ( {nullDecl with inlineD = (true, [snd _1]) } (*TODO*) )}
| _1 = Ttypedef
    {                ( {nullDecl with storageD = StoTypedef _1 } )}
| _1 = Tfriend
    {                ( {nullDecl with inlineD = (true, [_1]) } (*TODO*) )}
| _1 = storage_class_spec _2 = decl_spec
    {                                ( addStorageD _1 _2 )}
| _1 = type_spec _2 = decl_spec
    {                                ( addTypeD  _1 _2 )}
| _1 = cv_qualif _2 = decl_spec
    {                                ( addQualifD _1 _2 )}
| _1 = function_spec _2 = decl_spec
    {                                ( addInlineD (snd _1) _2 (*TODO*) )}
| _1 = Ttypedef _2 = decl_spec
    {                                ( addStorageD (StoTypedef _1) _2 )}
| _1 = Tfriend _2 = decl_spec
    {                                ( addInlineD _1 _2 (*TODO*))}

function_spec:
  _1 = Tinline
    {           ( Inline, _1 )}
| _1 = Tvirtual
    {            ( Virtual, _1 )}

storage_class_spec:
  _1 = Tstatic
    {                ( Sto (Static,  _1) )}
| _1 = Textern
    {                ( Sto (Extern,  _1) )}
| _1 = Tauto
    {                ( Sto (Auto,    _1) )}
| _1 = Tregister
    {                ( Sto (Register,_1) )}
| _1 = Tmutable
    {                ( Sto (Register,_1) (*TODO*) )}

init_declarator:
  _1 = declaratori
    {                                ( (_1, None) )}
| _1 = declaratori _2 = TEq _3 = initialize
    {                                ( (_1, Some (EqInit (_2, _3))) )}
| _1 = declaratori _2 = TOPar_CplusplusInit _3 = argument_list_opt _4 = TCPar
    {     ( (_1, Some (ObjInit (_2, _3, _4))) )}

declaratori:
  _1 = declarator
    {                             ( _1 )}
| _1 = declarator _2 = gcc_asm_decl
    {                             ( _1 )}

gcc_asm_decl:
  _1 = Tasm _2 = volatile_opt _3 = TOPar _4 = asmbody _5 = TCPar
    {                                                (  )}

initialize:
  _1 = assign_expr
    {     ( InitExpr _1 )}
| _1 = TOBrace _2 = initialize_list _3 = gcc_comma_opt_struct _4 = TCBrace
    {     ( InitList (_1, List.rev _2, _4) (*$3*) )}
| _1 = TOBrace _2 = TCBrace
    {     ( InitList (_1, [], _2) )}

initialize_list:
  _1 = initialize2
    {                                      ( [_1,   []] )}
| _1 = initialize_list _2 = TComma _3 = initialize2
    {                                      ( (_3,  [_2])::_1 )}

initialize2:
  _1 = cond_expr
    {     ( InitExpr _1 )}
| _1 = TOBrace _2 = initialize_list _3 = gcc_comma_opt_struct _4 = TCBrace
    {     ( InitList (_1, List.rev _2, _4) (*$3*) )}
| _1 = TOBrace _2 = TCBrace
    {     ( InitList (_1, [], _2) )}
| _1 = designator_list _2 = TEq _3 = initialize2
    {     ( InitDesignators (_1, _2, _3) )}
| _1 = ident _2 = TCol _3 = initialize2
    {     ( InitFieldOld (_1, _2, _3) )}
| _1 = TOCro _2 = const_expr _3 = TCCro _4 = initialize2
    {     ( InitIndexOld ((_1, _2, _3), _4) )}
| _1 = TOCro _2 = const_expr _3 = TCCro _4 = TEq _5 = initialize2
    {     ( InitDesignators ([DesignatorIndex(_1, _2, _3)], _4, _5) )}

designator:
  _1 = TDot _2 = ident
    {     ( DesignatorField (_1, _2) )}

gcc_comma_opt_struct:
  _1 = TComma
    {                    ( Some _1 )}
| 
    {                    ( None  )}

block_declaration:
  _1 = simple_declaration
    {                      ( _1 )}
| _1 = asm_definition
    {                      ( _1 )}
| _1 = namespace_alias_definition
    {                              ( _1 )}
| _1 = using_declaration
    {                     ( UsingDecl _1 )}
| _1 = using_directive
    {                     ( _1 )}

namespace_alias_definition:
  _1 = Tnamespace _2 = TIdent _3 = TEq _4 = tcolcol_opt _5 = nested_name_specifier_opt _6 = namespace_name _7 = TPtVirg
    {     ( let name = _4, _5, IdIdent _6 in NameSpaceAlias (_1, _2, _3, name, _7) )}

using_directive:
  _1 = Tusing _2 = Tnamespace _3 = tcolcol_opt _4 = nested_name_specifier_opt _5 = namespace_name _6 = TPtVirg
    {     ( let name = _3, _4, IdIdent _5 in UsingDirective (_1, _2, name, _6) )}

using_declaration:
  _1 = Tusing _2 = typename_opt _3 = tcolcol_opt _4 = nested_name_specifier _5 = unqualified_id _6 = TPtVirg
    {     ( let name = (_3, _4, _5) in _1, name, _6 (*$2*) )}
| _1 = Tusing _2 = typename_opt _3 = tcolcol_opt _4 = unqualified_id _5 = TPtVirg
    {     ( let name = (_3, [], _4) in _1, name, _5 (*$2*) )}

asm_definition:
  _1 = Tasm _2 = volatile_opt _3 = TOPar _4 = asmbody _5 = TCPar _6 = TPtVirg
    {     ( Asm(_1, _2, (_3, _4, _5), _6) )}

asmbody:
  _1 = string_list _2 = colon_asm_list
    {                               ( _1, _2 )}
| _1 = string_list
    {               ( _1, [] )}

colon_asm:
  _1 = TCol _2 = colon_option_list
    {                          ( Colon _2, [_1]   )}

colon_option:
  _1 = TString
    {                                ( ColonMisc, [snd _1] )}
| _1 = TString _2 = TOPar _3 = asm_expr _4 = TCPar
    {                                ( ColonExpr (_2, _3, _4), [snd _1] )}
| _1 = TOCro _2 = TIdent _3 = TCCro _4 = TString _5 = TOPar _6 = asm_expr _7 = TCPar
    {     ( ColonExpr (_5, _6, _7), [_1;snd _2;_3;snd _4] )}
| _1 = TIdent
    {                                    ( ColonMisc, [snd _1] )}
| 
    {                                    ( ColonMisc, [] )}

asm_expr:
  _1 = assign_expr
    {                      ( _1 )}

declaration:
  _1 = block_declaration
    {                                     ( BlockDecl _1 )}
| _1 = function_definition
    {                                     ( Func (FunctionOrMethod _1) )}
| _1 = ctor_dtor
    {             ( _1 )}
| _1 = template_declaration
    {                                     ( let (a,b,c) = _1 in TemplateDecl (a,b,c))}
| _1 = explicit_specialization
    {                                     ( _1 )}
| _1 = linkage_specification
    {                                     ( _1 )}
| _1 = namespace_definition
    {                                     ( _1 )}
| _1 = TPtVirg
    {              ( EmptyDef _1 )}

declaration_list_opt:
  
    {                 ( [] )}
| _1 = declaration_list
    {                    ( _1 )}

declaration_list:
  _1 = declaration_seq
    {                                    ( [_1]   )}
| _1 = declaration_list _2 = declaration_seq
    {                                    ( _1 @ [_2] )}

declaration_seq:
  _1 = declaration
    {               ( DeclElem _1 )}
| _1 = cpp_directive
    {     ( CppDirectiveDecl _1 )}
| _1 = cpp_ifdef_directive
    {     ( IfdefDecl _1 )}

template_declaration:
  _1 = Ttemplate _2 = TInf_Template _3 = template_parameter_list _4 = TSup_Template _5 = declaration
    {   ( (_1, (_2, _3, _4), _5) )}

explicit_specialization:
  _1 = Ttemplate _2 = TInf_Template _3 = TSup_Template _4 = declaration
    {     ( TemplateSpecialization (_1, (_2, (), _3), _4) )}

template_parameter:
  _1 = parameter_decl
    {                  ( _1 )}

linkage_specification:
  _1 = Textern _2 = TString _3 = declaration
    {     ( ExternC (_1, (snd _2), _3) )}
| _1 = Textern _2 = TString _3 = TOBrace _4 = declaration_list_opt _5 = TCBrace
    {     ( ExternCList (_1, (snd _2), (_3, _4, _5)) )}

namespace_definition:
  _1 = named_namespace_definition
    {                                ( _1 )}
| _1 = unnamed_namespace_definition
    {                                ( _1 )}

named_namespace_definition:
  _1 = Tnamespace _2 = TIdent _3 = TOBrace _4 = declaration_list_opt _5 = TCBrace
    {     ( NameSpace (_1, _2, (_3, _4, _5)) )}

unnamed_namespace_definition:
  _1 = Tnamespace _2 = TOBrace _3 = declaration_list_opt _4 = TCBrace
    {     ( NameSpaceAnon (_1, (_2, _3, _4)) )}

ctor_dtor:
  _1 = nested_name_specifier _2 = TIdent_Constructor _3 = TOPar _4 = parameter_type_list_opt _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( DeclTodo )}
| _1 = nested_name_specifier _2 = TTilde _3 = ident _4 = TOPar _5 = void_opt _6 = TCPar _7 = compound
    {     ( DeclTodo )}
| _1 = inline_opt _2 = TIdent_Constructor _3 = TOPar _4 = parameter_type_list_opt _5 = TCPar _6 = ctor_mem_initializer_list_opt _7 = compound
    {     ( DeclTodo )}
| _1 = TTilde _2 = ident _3 = TOPar _4 = void_opt _5 = TCPar _6 = exn_spec_opt _7 = compound
    {     ( DeclTodo )}

function_definition:
  _1 = start_fun _2 = compound
    {     ( fixFunc (_1, _2) )}

start_fun:
  _1 = decl_spec _2 = declarator
    {     ( let (t_ret, sto) = type_and_storage_for_funcdef_from_decl _1 in
       (fst _2, fixOldCDecl ((snd _2) t_ret), sto)
     )}

cpp_directive:
  _1 = TInclude
    {     ( let (_include_str, filename, tok) = _1 in
       (* redo some lexing work :( *)
       let inc_kind, path =
         match () with
         | _ when filename =~ "^\"\\(.*\\)\"$" ->  Local, matched1 filename
         | _ when filename =~ "^\\<\\(.*\\)\\>$" -> Standard, matched1 filename
         | _ -> Weird, filename
       in
       Include (tok, inc_kind, path)
     )}
| _1 = TDefine _2 = TIdent_Define _3 = define_val _4 = TCommentNewline_DefineEndOfMacro
    {     ( Define (_1, _2, DefineVar, _3) (*$4??*) )}
| _1 = TDefine _2 = TIdent_Define _3 = TOPar_Define _4 = param_define_list_opt _5 = TCPar _6 = define_val _7 = TCommentNewline_DefineEndOfMacro
    {     ( Define (_1, _2, (DefineFunc (_3, _4, _5)), _6) (*$7*) )}
| _1 = TUndef
    {                      ( Undef _1 )}
| _1 = TCppDirectiveOther
    {                      ( PragmaAndCo _1 )}

define_val:
  _1 = expr
    {             ( DefineExpr _1 )}
| _1 = statement
    {             ( DefineStmt _1 )}
| _1 = Tdo _2 = statement _3 = Twhile _4 = TOPar _5 = expr _6 = TCPar
    {     ( match _5 with
       | (C (Int ("0"))), [tok] -> DefineDoWhileZero (_2,  [_1;_3;_4;tok;_6])
       | _ -> raise Parsing.Parse_error
     )}
| _1 = Tif _2 = TOPar _3 = expr _4 = TCPar _5 = id_expression
    {     ( let name = (None, fst _5, snd _5) in
       DefinePrintWrapper (_1, (_2, _3, _4), name)
     )}
| _1 = TOBrace_DefineInit _2 = initialize_list _3 = TCBrace _4 = comma_opt
    {    ( DefineInit (InitList (_1, List.rev _2, _3) (*$4*))  )}
| 
    {                   ( DefineEmpty )}

param_define:
  _1 = ident
    {                       ( fst _1, [snd _1] )}
| _1 = TDefParamVariadic
    {                        ( fst _1, [snd _1] )}
| _1 = TEllipsis
    {                        ( "...", [_1] )}
| _1 = Tregister
    {                        ( "register", [_1] )}
| _1 = Tnew
    {                        ( "new", [_1] )}

cpp_ifdef_directive:
  _1 = TIfdef
    {              ( Ifdef, _1 )}
| _1 = TIfdefelse
    {              ( IfdefElse, _1 )}
| _1 = TIfdefelif
    {              ( IfdefElseif, _1 )}
| _1 = TEndif
    {              ( IfdefEndif, _1 )}
| _1 = TIfdefBool
    {               ( Ifdef, snd _1 )}
| _1 = TIfdefMisc
    {               ( Ifdef, snd _1 )}
| _1 = TIfdefVersion
    {                 ( Ifdef, snd _1 )}

cpp_other:
  _1 = TIdent _2 = TOPar _3 = argument_list _4 = TCPar _5 = TPtVirg
    {     ( MacroTop (_1, (_2, _3, _4), Some _5) )}
| _1 = TIdent _2 = TOPar _3 = argument_list _4 = TCPar_EOL
    {     ( MacroTop (_1, (_2, _3, _4), None) )}
| _1 = TIdent _2 = TPtVirg
    {                  ( MacroVarTop (_1, _2) )}

toplevel:
  _1 = toplevel_aux
    {                ( Some _1 )}
| _1 = EOF
    {                ( None )}

toplevel_aux:
  _1 = declaration
    {                       ( DeclElem _1 )}
| _1 = cpp_directive
    {                       ( CppDirectiveDecl _1 )}
| _1 = cpp_ifdef_directive
    {                                                             ( IfdefDecl _1 )}
| _1 = cpp_other
    {                       ( _1 )}
| _1 = TCBrace
    {           ( DeclElem (EmptyDef _1) )}

string_list:
  _1 = string_elem
    {               ( _1 )}
| _1 = string_list _2 = string_elem
    {                           ( _1 @ _2 )}

colon_asm_list:
  _1 = colon_asm
    {             ( [_1] )}
| _1 = colon_asm_list _2 = colon_asm
    {                             ( _1 @ [_2] )}

colon_option_list:
  _1 = colon_option
    {                ( [_1, []] )}
| _1 = colon_option_list _2 = TComma _3 = colon_option
    {                                         ( _1 @ [_3, [_2]] )}

argument_list:
  _1 = argument
    {                                      ( [_1, []] )}
| _1 = argument_list _2 = TComma _3 = argument
    {                                 ( _1 @ [_3,    [_2]] )}

enumerator_list:
  _1 = enumerator
    {                                     ( [_1,          []]   )}
| _1 = enumerator_list _2 = TComma _3 = enumerator
    {                                     ( _1 @ [_3,    [_2]] )}

init_declarator_list:
  _1 = init_declarator
    {                                               ( [_1,   []] )}
| _1 = init_declarator_list _2 = TComma _3 = init_declarator
    {                                               ( _1 @ [_3,     [_2]] )}

member_declarator_list:
  _1 = member_declarator
    {                                                 ( [_1,   []] )}
| _1 = member_declarator_list _2 = TComma _3 = member_declarator
    {                                                   ( _1 @ [_3,     [_2]] )}

param_define_list_opt:
  
    {                   ( [] )}
| _1 = param_define
    {                                          ( [_1, []] )}
| _1 = param_define_list_opt _2 = TComma _3 = param_define
    {                                              ( _1 @ [_3, [_2]] )}

designator_list:
  _1 = designator
    {              ( [_1] )}
| _1 = designator_list _2 = designator
    {                              ( _1 @ [_2] )}

handler_list:
  _1 = handler
    {           ( [_1] )}
| _1 = handler_list _2 = handler
    {                        ( _1 @ [_2] )}

mem_initializer_list:
  _1 = mem_initializer
    {                                             ( [_1, []] )}
| _1 = mem_initializer_list _2 = TComma _3 = mem_initializer
    {                                                ( _1 @ [_3, [_2]] )}

template_argument_list:
  _1 = template_argument
    {                     ( [_1, []] )}
| _1 = template_argument_list _2 = TComma _3 = template_argument
    {                                                   ( _1 @ [_3, [_2]] )}

template_parameter_list:
  _1 = template_parameter
    {                      ( [_1, []] )}
| _1 = template_parameter_list _2 = TComma _3 = template_parameter
    {                                                     ( _1 @ [_3, [_2]] )}

base_specifier_list:
  _1 = base_specifier
    {                                                ( [_1,           []] )}
| _1 = base_specifier_list _2 = TComma _3 = base_specifier
    {                                                ( _1 @ [_3,     [_2]] )}

gcc_comma_opt:
  _1 = TComma
    {          (  [_1] )}
| 
    {                    (  []  )}

comma_opt:
  _1 = TComma
    {          ( [_1] )}
| 
    {   ( [] )}

assign_expr_opt:
  _1 = assign_expr
    {                   ( Some _1 )}
| 
    {                   ( None )}

expr_opt:
  _1 = expr
    {                   ( Some _1 )}
| 
    {                   ( None )}

argument_list_opt:
  _1 = argument_list
    {                 ( _1 )}
| 
    {                 ( [] )}

parameter_type_list_opt:
  _1 = parameter_type_list
    {                       ( Some _1 )}
| 
    {                       ( None )}

member_specification_opt:
  _1 = member_specification
    {                        ( _1 )}
| 
    {                        ( [] )}

nested_name_specifier_opt:
  _1 = nested_name_specifier
    {                         ( _1 )}
| 
    {                         ( [] )}

nested_name_specifier_opt2:
  _1 = nested_name_specifier2
    {                          ( _1 )}
| 
    {                          ( [] )}

exn_spec_opt:
  _1 = exception_specification
    {                           ( Some _1 )}
| 
    {                           ( None )}

new_placement_opt:
  _1 = new_placement
    {                 ( Some _1 )}
| 
    {                 ( None )}

new_initializer_opt:
  _1 = new_initializer
    {                   ( Some _1 )}
| 
    {                 ( None )}

base_clause_opt:
  _1 = base_clause
    {                 ( Some _1 )}
| 
    {                 ( None )}

typename_opt:
  _1 = Ttypename
    {                 ( [_1] )}
| 
    {                 ( [] )}

template_opt:
  _1 = Ttemplate
    {                 ( [_1] )}
| 
    {                 ( [] )}

void_opt:
  _1 = Tvoid
    {                 ( Some _1 )}
| 
    {                 ( None )}

inline_opt:
  _1 = Tinline
    {                   ( Some _1 )}
| 
    {                 ( None )}

volatile_opt:
  _1 = Tvolatile
    {                 ( Some _1 )}
| 
    {                 ( None )}

tcolcol_opt:
  _1 = TColCol
    {                   ( Some _1 )}
| 
    {                   ( None )}

%%


