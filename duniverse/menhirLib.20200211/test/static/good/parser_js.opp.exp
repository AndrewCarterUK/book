File "parser_js.mly", line 70, characters 52-60:
Warning: the token TComment is unused.
File "parser_js.mly", line 70, characters 34-49:
Warning: the token TCommentNewline is unused.
File "parser_js.mly", line 70, characters 20-33:
Warning: the token TCommentSpace is unused.
File "parser_js.mly", line 143, characters 20-28:
Warning: the token TUnknown is unused.
%{
(*
 * src: ocamlyaccified from Marcel Laverdet 'fbjs2' via emacs macros, itself
 * extracted from the official ECMAscript specification at:
 * http://www.ecma-international.org/publications/standards/ecma-262.htm
 *
 * See also http://en.wikipedia.org/wiki/ECMAScript_syntax
 *
 * related work:
 *  - http://esprima.org/, js parser in js
 *  - http://marijnhaverbeke.nl/parse-js/, js parser in common lisp
 *    (which has been since ported to javascript by nodejs people)
 *  - jslint
 *
 * updates:
 *  - support for ES6 class, see
 *    http://people.mozilla.org/~jorendorff/es6-draft.html#sec-class-definitions
 *  - support for JSX, mostly imitating what was done for XHP in lang_php/,
 *    but with tags possibly containing ':' in their name
 *  - support for type annotation a la TypeScript, see
 *    http://en.wikipedia.org/wiki/TypeScript, see also D911357 for the
 *    esprima related extension
 *  - support arrows (short lambdas), see
 *    https://people.mozilla.org/~jorendorff/es6-draft.html#sec-arrow-function-definitions
 *  - support trailing commas
 *  - variable number of parameters, e.g. 'function foo(...args)', es6 ext?
 *  - interpolated strings, see
 *    https://gist.github.com/lukehoban/9303054#template-strings
 *)

open Common

open Ast_js

let e x = (x)
let bop op a b c = e(B(a, (op, b), c))
let uop op a b = e(U((op,a), b))
let mk_param x = { p_name = x; p_type = None; p_default = None; p_dots = None; }

let fake_tok s = {
  Parse_info.
  token = Parse_info.FakeTokStr (s, None);
  transfo = Parse_info.NoTransfo;
}

%}
%start main
%token <Ast_js.tok> EOF
%token <Ast_js.tok> TComment
%token <Ast_js.tok> TCommentNewline
%token <Ast_js.tok> TCommentSpace
%token <Ast_js.tok> TUnknown
%token <Ast_js.tok> T_AND
%token <Ast_js.tok> T_ARROW
%token <Ast_js.tok> T_ASSIGN
%token <Ast_js.tok> T_BACKQUOTE
%token <Ast_js.tok> T_BIT_AND
%token <Ast_js.tok> T_BIT_AND_ASSIGN
%token <Ast_js.tok> T_BIT_NOT
%token <Ast_js.tok> T_BIT_OR
%token <Ast_js.tok> T_BIT_OR_ASSIGN
%token <Ast_js.tok> T_BIT_XOR
%token <Ast_js.tok> T_BIT_XOR_ASSIGN
%token <Ast_js.tok> T_BREAK
%token <Ast_js.tok> T_CASE
%token <Ast_js.tok> T_CATCH
%token <Ast_js.tok> T_CLASS
%token <Ast_js.tok> T_COLON
%token <Ast_js.tok> T_COMMA
%token <Ast_js.tok> T_CONST
%token <Ast_js.tok> T_CONTINUE
%token <Ast_js.tok> T_DECR
%token <Ast_js.tok> T_DEFAULT
%token <Ast_js.tok> T_DELETE
%token <Ast_js.tok> T_DIV
%token <Ast_js.tok> T_DIV_ASSIGN
%token <Ast_js.tok> T_DO
%token <Ast_js.tok> T_DOLLARCURLY
%token <Ast_js.tok> T_DOTS
%token <Ast_js.tok> T_ELSE
%token <string * Ast_js.tok> T_ENCAPSED_STRING
%token <Ast_js.tok> T_EQUAL
%token <Ast_js.tok> T_EXTENDS
%token <Ast_js.tok> T_FALSE
%token <Ast_js.tok> T_FINALLY
%token <Ast_js.tok> T_FOR
%token <Ast_js.tok> T_FUNCTION
%token <Ast_js.tok> T_GREATER_THAN
%token <Ast_js.tok> T_GREATER_THAN_EQUAL
%token <string * Ast_js.tok> T_IDENTIFIER
%token <Ast_js.tok> T_IF
%token <Ast_js.tok> T_IN
%token <Ast_js.tok> T_INCR
%token <Ast_js.tok> T_INSTANCEOF
%token <Ast_js.tok> T_INTERFACE
%token <Ast_js.tok> T_LBRACKET
%token <Ast_js.tok> T_LCURLY
%token <Ast_js.tok> T_LESS_THAN
%token <Ast_js.tok> T_LESS_THAN_EQUAL
%token <Ast_js.tok> T_LPAREN
%token <Ast_js.tok> T_LSHIFT
%token <Ast_js.tok> T_LSHIFT_ASSIGN
%token <Ast_js.tok> T_MINUS
%token <Ast_js.tok> T_MINUS_ASSIGN
%token <Ast_js.tok> T_MOD
%token <Ast_js.tok> T_MOD_ASSIGN
%token <Ast_js.tok> T_MULT
%token <Ast_js.tok> T_MULT_ASSIGN
%token <Ast_js.tok> T_NEW
%token <Ast_js.tok> T_NOT
%token <Ast_js.tok> T_NOT_EQUAL
%token <Ast_js.tok> T_NULL
%token <string * Ast_js.tok> T_NUMBER
%token <Ast_js.tok> T_OR
%token <Ast_js.tok> T_PERIOD
%token <Ast_js.tok> T_PLING
%token <Ast_js.tok> T_PLUS
%token <Ast_js.tok> T_PLUS_ASSIGN
%token <Ast_js.tok> T_RBRACKET
%token <Ast_js.tok> T_RCURLY
%token <string * Ast_js.tok> T_REGEX
%token <Ast_js.tok> T_RETURN
%token <Ast_js.tok> T_RPAREN
%token <Ast_js.tok> T_RSHIFT
%token <Ast_js.tok> T_RSHIFT3
%token <Ast_js.tok> T_RSHIFT3_ASSIGN
%token <Ast_js.tok> T_RSHIFT_ASSIGN
%token <Ast_js.tok> T_SEMICOLON
%token <Ast_js.tok> T_STATIC
%token <Ast_js.tok> T_STRICT_EQUAL
%token <Ast_js.tok> T_STRICT_NOT_EQUAL
%token <string * Ast_js.tok> T_STRING
%token <Ast_js.tok> T_SWITCH
%token <Ast_js.tok> T_THIS
%token <Ast_js.tok> T_THROW
%token <Ast_js.tok> T_TRUE
%token <Ast_js.tok> T_TRY
%token <Ast_js.tok> T_TYPEOF
%token <Ast_js.tok> T_VAR
%token <Ast_js.tok> T_VIRTUAL_SEMICOLON
%token <Ast_js.tok> T_VOID
%token <Ast_js.tok> T_WHILE
%token <Ast_js.tok> T_WITH
%token <string * Parse_info.info> T_XHP_ATTR
%token <string option * Parse_info.info> T_XHP_CLOSE_TAG
%token <Parse_info.info> T_XHP_GT
%token <string * Parse_info.info> T_XHP_OPEN_TAG
%token <Parse_info.info> T_XHP_SLASH_GT
%token <string * Parse_info.info> T_XHP_TEXT
%nonassoc LOW_PRIORITY_RULE
%nonassoc p_IF
%nonassoc T_ELSE
%nonassoc p_POSTFIX
%right T_ASSIGN T_BIT_AND_ASSIGN T_BIT_OR_ASSIGN T_BIT_XOR_ASSIGN T_DIV_ASSIGN T_LSHIFT_ASSIGN T_MINUS_ASSIGN T_MOD_ASSIGN T_MULT_ASSIGN T_PLUS_ASSIGN T_RSHIFT3_ASSIGN T_RSHIFT_ASSIGN
%left T_OR
%left T_AND
%left T_BIT_OR
%left T_BIT_XOR
%left T_BIT_AND
%left T_EQUAL T_NOT_EQUAL T_STRICT_EQUAL T_STRICT_NOT_EQUAL
%left T_GREATER_THAN T_GREATER_THAN_EQUAL T_IN T_INSTANCEOF T_LESS_THAN T_LESS_THAN_EQUAL
%left T_LSHIFT T_RSHIFT T_RSHIFT3
%left T_MINUS T_PLUS
%left T_DIV T_MOD T_MULT
%right T_BIT_NOT T_DECR T_DELETE T_INCR T_NOT T_TYPEOF T_VOID
%type <Ast_js.toplevel list> main
%%

main:
  _1 = program _2 = EOF
    {                  ( _1 )}

program:
  _1 = statement_list
    {                        ( _1 )}

source_element:
  _1 = statement
    {                        ( St _1 )}
| _1 = declaration
    {               ( _1 )}

declaration:
  _1 = function_declaration
    {                        ( FunDecl _1 )}
| _1 = class_declaration
    {                     ( ClassDecl _1 )}
| _1 = interface_declaration
    {                         ( InterfaceDecl _1 )}

statement:
  _1 = block
    {                        ( _1 )}
| _1 = variable_statement
    {                        ( _1 )}
| _1 = empty_statement
    {                        ( _1 )}
| _1 = expression_statement
    {                        ( _1 )}
| _1 = if_statement
    {                        ( _1 )}
| _1 = iteration_statement
    {                        ( _1 )}
| _1 = continue_statement
    {                        ( _1 )}
| _1 = break_statement
    {                        ( _1 )}
| _1 = return_statement
    {                        ( _1 )}
| _1 = with_statement
    {                        ( _1 )}
| _1 = labelled_statement
    {                        ( _1 )}
| _1 = switch_statement
    {                        ( _1 )}
| _1 = throw_statement
    {                        ( _1 )}
| _1 = try_statement
    {                        ( _1 )}

block:
  _1 = T_LCURLY _2 = statement_list _3 = T_RCURLY
    {                                    ( Block (_1, _2, _3) )}
| _1 = T_LCURLY _2 = T_RCURLY
    {                                    ( Block (_1, [], _2) )}

variable_statement:
  _1 = T_VAR _2 = variable_declaration_list _3 = semicolon
    {                                              ( Variable (_1, _2, _3) )}
| _1 = T_CONST _2 = variable_declaration_list _3 = semicolon
    {                                               ( Const (_1, _2, _3) )}

variable_declaration:
  _1 = identifier _2 = annotation_opt _3 = initializeur_opt
    {     ( { v_name = _1; v_type = _2; v_init = _3 } )}

initializeur:
  _1 = T_ASSIGN _2 = assignment_expression
    {                                  ( _1, _2 )}

empty_statement:
  _1 = semicolon
    {             ( Nop _1 )}

expression_statement:
  _1 = expression_no_statement _2 = semicolon
    {                                     ( ExprStmt (_1, _2) )}

if_statement:
  _1 = T_IF _2 = T_LPAREN _3 = expression _4 = T_RPAREN _5 = statement _6 = T_ELSE _7 = statement
    {     ( If (_1, (_2, _3, _4), _5, Some (_6, _7)) )}
| _1 = T_IF _2 = T_LPAREN _3 = expression _4 = T_RPAREN _5 = statement %prec p_IF
    {     ( If (_1, (_2, _3, _4), _5, None) )}

iteration_statement:
  _1 = T_DO _2 = statement _3 = T_WHILE _4 = T_LPAREN _5 = expression _6 = T_RPAREN _7 = semicolon
    {     ( Do (_1, _2, _3, (_4, _5, _6), _7) )}
| _1 = T_WHILE _2 = T_LPAREN _3 = expression _4 = T_RPAREN _5 = statement
    {     ( While (_1, (_2, _3, _4), _5) )}
| _1 = T_FOR _2 = T_LPAREN _3 = expression_no_in_opt _4 = T_SEMICOLON _5 = expression_opt _6 = T_SEMICOLON _7 = expression_opt _8 = T_RPAREN _9 = statement
    {     ( For (_1, _2, _3 +>Common2.fmap (fun x -> LHS x), _4, _5, _6, _7, _8, _9) )}
| _1 = T_FOR _2 = T_LPAREN _3 = T_VAR _4 = variable_declaration_list_no_in _5 = T_SEMICOLON _6 = expression_opt _7 = T_SEMICOLON _8 = expression_opt _9 = T_RPAREN _10 = statement
    {     ( For (_1, _2, Some (Vars (_3, _4)), _5, _6, _7, _8, _9, _10) )}
| _1 = T_FOR _2 = T_LPAREN _3 = left_hand_side_expression _4 = T_IN _5 = expression _6 = T_RPAREN _7 = statement
    {     ( ForIn (_1, _2, LHS _3, _4, _5, _6, _7) )}
| _1 = T_FOR _2 = T_LPAREN _3 = T_VAR _4 = variable_declaration_list_no_in _5 = T_IN _6 = expression _7 = T_RPAREN _8 = statement
    {     ( ForIn (_1, _2, Vars (_3, _4), _5, _6, _7, _8) )}

variable_declaration_no_in:
  _1 = identifier _2 = initializer_no_in
    {     ( { v_name = _1; v_init = Some _2; v_type =None } )}
| _1 = identifier
    {     ( { v_name = _1; v_init = None; v_type = None } )}

initializer_no_in:
  _1 = T_ASSIGN _2 = assignment_expression_no_in
    {                                        ( _1, _2 )}

continue_statement:
  _1 = T_CONTINUE _2 = identifier _3 = semicolon
    {                                   ( Continue (_1, Some _2, _3) )}
| _1 = T_CONTINUE _2 = semicolon
    {                                   ( Continue (_1, None, _2) )}

break_statement:
  _1 = T_BREAK _2 = identifier _3 = semicolon
    {                                ( Break (_1, Some _2, _3) )}
| _1 = T_BREAK _2 = semicolon
    {                                ( Break (_1, None, _2) )}

return_statement:
  _1 = T_RETURN _2 = expression _3 = semicolon
    {                                 ( Return (_1, Some _2, _3) )}
| _1 = T_RETURN _2 = semicolon
    {                                 ( Return (_1, None, _2) )}

with_statement:
  _1 = T_WITH _2 = T_LPAREN _3 = expression _4 = T_RPAREN _5 = statement
    {                                                 ( With (_1, (_2, _3, _4), _5) )}

switch_statement:
  _1 = T_SWITCH _2 = T_LPAREN _3 = expression _4 = T_RPAREN _5 = case_block
    {                                                    ( Switch (_1, (_2, _3, _4), _5) )}

labelled_statement:
  _1 = identifier _2 = T_COLON _3 = statement
    {                                ( Labeled (_1, _2, _3) )}

throw_statement:
  _1 = T_THROW _2 = expression _3 = semicolon
    {                                ( Throw (_1, _2, _3) )}

try_statement:
  _1 = T_TRY _2 = block _3 = catch
    {                             ( Try (_1, _2, Some _3, None)  )}
| _1 = T_TRY _2 = block _3 = finally
    {                             ( Try (_1, _2, None, Some _3) )}
| _1 = T_TRY _2 = block _3 = catch _4 = finally
    {                             ( Try (_1, _2, Some _3, Some _4) )}

catch:
  _1 = T_CATCH _2 = T_LPAREN _3 = identifier _4 = T_RPAREN _5 = block
    {                                              ( _1, (_2, _3, _4), _5 )}

finally:
  _1 = T_FINALLY _2 = block
    {                   ( _1, _2 )}

case_block:
  _1 = T_LCURLY _2 = case_clauses_opt _3 = T_RCURLY
    {     ( (_1, _2, _3) )}
| _1 = T_LCURLY _2 = case_clauses_opt _3 = default_clause _4 = case_clauses_opt _5 = T_RCURLY
    {     ( (_1, _2 @ [_3] @ _4, _5) )}

case_clause:
  _1 = T_CASE _2 = expression _3 = T_COLON _4 = statement_list
    {                                            ( Case (_1, _2, _3, _4) )}
| _1 = T_CASE _2 = expression _3 = T_COLON
    {                             ( Case (_1, _2, _3, []) )}

default_clause:
  _1 = T_DEFAULT _2 = T_COLON
    {                     ( Default (_1, _2, []))}
| _1 = T_DEFAULT _2 = T_COLON _3 = statement_list
    {                                    ( Default (_1, _2, _3) )}

function_declaration:
  _1 = T_FUNCTION _2 = identifier _3 = generics_opt _4 = T_LPAREN _5 = formal_parameter_list_opt _6 = T_RPAREN _7 = annotation_opt _8 = T_LCURLY _9 = function_body _10 = T_RCURLY
    {     ( { f_tok = Some _1; f_name= Some _2; f_type_params = _3;
         f_params= (_4, _5, _6);
         f_return_type = _7; f_body = (_8, _9, _10)
     } )}

function_expression:
  _1 = T_FUNCTION _2 = identifier_opt _3 = generics_opt _4 = T_LPAREN _5 = formal_parameter_list_opt _6 = T_RPAREN _7 = annotation_opt _8 = T_LCURLY _9 = function_body _10 = T_RCURLY
    {     ( e(Function { f_tok = Some _1; f_name= _2; f_type_params = _3;
                    f_params= (_4, _5, _6);
                    f_return_type = _7; f_body = (_8, _9, _10) }) )}

formal_parameter:
  _1 = identifier
    {                         ( mk_param _1 )}
| _1 = identifier _2 = annotation
    {                         ( { (mk_param _1) with p_type = Some _2; } )}

formal_optional_parameter:
  _1 = identifier _2 = T_PLING
    {     ( { (mk_param _1) with p_default = Some(DNone _2); } )}
| _1 = identifier _2 = T_PLING _3 = annotation
    {     ( { (mk_param _1) with p_type = Some _3; p_default = Some(DNone _2); } )}
| _1 = identifier _2 = initializeur
    {     ( let (tok,e) = _2 in { (mk_param _1) with p_default = Some(DSome(tok,e)); } )}
| _1 = identifier _2 = annotation _3 = initializeur
    {     ( let (tok,e) = _3 in { (mk_param _1) with p_type = Some _2; p_default = Some(DSome(tok,e)); } )}

formal_rest_parameter:
  _1 = T_DOTS _2 = identifier
    {                     ( { (mk_param _2) with p_dots = Some _1; } )}
| _1 = T_DOTS _2 = identifier _3 = annotation
    {     ( { (mk_param _2) with p_dots = Some _1; p_type = Some _3;
       } )}

formal_parameter_list:
  _1 = formal_parameter _2 = T_COMMA _3 = formal_parameter_list
    {     ( (Left _1)::(Right _2)::_3 )}
| _1 = formal_parameter
    {                     ( [Left _1] )}
| _1 = formal_optional_parameter_list
    {                                  ( _1 )}

formal_optional_parameter_list:
  _1 = formal_optional_parameter _2 = T_COMMA _3 = formal_optional_parameter_list
    {     ( (Left _1)::(Right _2)::_3 )}
| _1 = formal_optional_parameter
    {                             ( [Left _1] )}
| _1 = formal_rest_parameter
    {                         ( [Left _1] )}

function_body:
  
    {                   ( [] )}
| _1 = statement_list
    {                   ( _1 )}

class_declaration:
  _1 = T_CLASS _2 = binding_identifier _3 = generics_opt _4 = class_tail
    {   (
     let (extends, body) = _4 in
     { c_tok = _1;
       c_name = _2;
       c_type_params = _3;
       c_extends =extends;
       c_body = body
     }
   )}

class_tail:
  _1 = class_heritage_opt _2 = T_LCURLY _3 = class_body_opt _4 = T_RCURLY
    {                                                                ( _1,(_2,_3,_4))}

class_heritage:
  _1 = T_EXTENDS _2 = type_expression
    {                                          ( (_1, _2) )}

class_body:
  _1 = class_element_list
    {                               ( _1 )}

class_element:
  _1 = identifier _2 = annotation _3 = semicolon
    {                                   ( Field (_1, _2, _3) )}
| _1 = method_definition
    {                              ( Method (None, _1) )}
| _1 = T_STATIC _2 = method_definition
    {                              ( Method (Some _1, _2) )}
| _1 = semicolon
    {             ( ClassExtraSemiColon _1 )}

binding_identifier:
  _1 = identifier
    {                               ( _1 )}

method_definition:
  _1 = identifier _2 = generics_opt _3 = T_LPAREN _4 = formal_parameter_list_opt _5 = T_RPAREN _6 = annotation_opt _7 = T_LCURLY _8 = function_body _9 = T_RCURLY
    {  ( { f_tok = None; f_name = Some _1; f_type_params = _2;
      f_params = (_3, _4, _5);
      f_return_type = _6; f_body =  (_7, _8, _9)
  } )}

interface_declaration:
  _1 = T_INTERFACE _2 = binding_identifier _3 = generics_opt _4 = type_
    {   (
     { i_tok = _1;
       i_name = _2;
       i_type_params = _3;
       i_type = _4;
     }
   )}

annotation:
  _1 = T_COLON _2 = type_
    {                          ( TAnnot(_1, _2) )}

complex_annotation:
  _1 = annotation
    {              ( _1 )}
| _1 = generics_opt _2 = T_LPAREN _3 = param_type_list_opt _4 = T_RPAREN _5 = T_COLON _6 = type_
    {     ( TFunAnnot(_1,(_2,_3,_4),_5,_6) )}

type_:
  _1 = T_VOID
    {                 ( TName (V("void", _1), None) )}
| _1 = nominal_type
    {                ( TName(_1) )}
| _1 = T_PLING _2 = type_
    {                 ( TQuestion (_1, _2) )}
| _1 = T_LPAREN _2 = param_type_list_opt _3 = T_RPAREN _4 = T_ARROW _5 = type_
    {     ( TFun ((_1, _2, _3), _4, _5) )}
| _1 = T_LCURLY _2 = field_type_list_opt _3 = T_RCURLY
    {                                                 ( TObj (_1, _2, _3) )}

field_type:
  _1 = T_IDENTIFIER _2 = complex_annotation _3 = semicolon
    {                                                      ( (_1, _2, _3) )}

field_type_list:
  _1 = field_type
    {              ( [_1] )}
| _1 = field_type_list _2 = field_type
    {                              ( _1 @ [_2] )}

param_type:
  _1 = T_IDENTIFIER _2 = complex_annotation
    {  ( (RequiredParam(_1), _2) )}

optional_param_type:
  _1 = T_IDENTIFIER _2 = T_PLING _3 = complex_annotation
    {  ( (OptionalParam(_1,_2), _3) )}

rest_param_type:
  _1 = T_DOTS _2 = T_IDENTIFIER _3 = complex_annotation
    {  ( (RestParam(_1,_2), _3) )}

param_type_list:
  _1 = param_type _2 = T_COMMA _3 = param_type_list
    {                                      ( (Left _1)::(Right _2)::_3 )}
| _1 = param_type
    {                                      ( [Left _1] )}
| _1 = optional_param_type_list
    {                                      ( _1 )}

optional_param_type_list:
  _1 = optional_param_type _2 = T_COMMA _3 = optional_param_type_list
    {     ( (Left _1)::(Right _2)::_3 )}
| _1 = optional_param_type
    {                             ( [Left _1] )}
| _1 = rest_param_type
    {                             ( [Left _1] )}

type_variable:
  _1 = identifier
    {              ( _1 )}

type_variable_list:
  _1 = type_variable
    {                                            ( [Left _1] )}
| _1 = type_variable_list _2 = T_COMMA _3 = type_variable
    {                                            ( _1 @ [Right _2; Left _3] )}

generics:
  _1 = T_LESS_THAN _2 = type_variable_list _3 = T_GREATER_THAN
    {                                                 ( _1, _2, _3 )}

type_reference:
  _1 = identifier
    {              ( V(_1) )}

nominal_type:
  _1 = type_reference
    {                  ( (_1,None) )}
| _1 = type_reference _2 = type_arguments
    {                                 ( (_1, Some _2) )}

type_arguments:
  _1 = T_LESS_THAN _2 = type_argument_list _3 = T_GREATER_THAN
    {                                                 ( _1, _2, _3 )}
| _1 = mismatched_type_arguments
    {                             ( _1 )}

type_argument_list:
  _1 = type_
    {                                    ( [Left _1] )}
| _1 = type_argument_list _2 = T_COMMA _3 = type_
    {                                    ( _1 @ [Right _2; Left _3] )}

mismatched_type_arguments:
  _1 = T_LESS_THAN _2 = type_argument_list1 _3 = T_RSHIFT
    {                                            ( _1, _2, _3 )}
| _1 = T_LESS_THAN _2 = type_argument_list2 _3 = T_RSHIFT3
    {                                             ( _1, _2, _3 )}

type_argument_list1:
  _1 = nominal_type1
    {                                            ( [Left (TName _1)] )}
| _1 = type_argument_list _2 = T_COMMA _3 = nominal_type1
    {                                            ( _1 @ [Right _2; Left (TName _3)] )}

nominal_type1:
  _1 = type_reference _2 = type_arguments1
    {                                  ( (_1, Some _2) )}

type_arguments1:
  _1 = T_LESS_THAN _2 = type_argument_list
    {                                  ( _1, _2, fake_tok ">" )}

type_argument_list2:
  _1 = nominal_type2
    {                                            ( [Left (TName _1)] )}
| _1 = type_argument_list _2 = T_COMMA _3 = nominal_type2
    {                                            ( _1 @ [Right _2; Left (TName _3)] )}

nominal_type2:
  _1 = type_reference _2 = type_arguments2
    {                                  ( (_1, Some _2) )}

type_arguments2:
  _1 = T_LESS_THAN _2 = type_argument_list1
    {                                   ( _1, _2, fake_tok ">" )}

type_expression:
  _1 = left_hand_side_expression_no_statement
    {                                          ( (_1,None) )}
| _1 = type_reference _2 = type_arguments
    {                                 ( (_1, Some _2) )}

expression:
  _1 = assignment_expression
    {                         ( _1 )}
| _1 = expression _2 = T_COMMA _3 = assignment_expression
    {                                            ( e(Seq (_1, _2, _3)) )}

assignment_expression:
  _1 = conditional_expression
    {                          ( _1 )}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression
    {     ( e(Assign (_1, _2, _3)) )}
| _1 = arrow_function
    {                  ( Arrow _1 )}

assignment_operator:
  _1 = T_ASSIGN
    {                    ( A_eq , _1 )}
| _1 = T_MULT_ASSIGN
    {                    ( A_mul, _1 )}
| _1 = T_DIV_ASSIGN
    {                    ( A_div, _1 )}
| _1 = T_MOD_ASSIGN
    {                    ( A_mod, _1 )}
| _1 = T_PLUS_ASSIGN
    {                    ( A_add, _1 )}
| _1 = T_MINUS_ASSIGN
    {                    ( A_sub, _1 )}
| _1 = T_LSHIFT_ASSIGN
    {                    ( A_lsl, _1 )}
| _1 = T_RSHIFT_ASSIGN
    {                    ( A_lsr, _1 )}
| _1 = T_RSHIFT3_ASSIGN
    {                    ( A_asr, _1 )}
| _1 = T_BIT_AND_ASSIGN
    {                    ( A_and, _1 )}
| _1 = T_BIT_XOR_ASSIGN
    {                    ( A_xor, _1 )}
| _1 = T_BIT_OR_ASSIGN
    {                    ( A_or , _1 )}

left_hand_side_expression:
  _1 = new_expression
    {                   ( _1 )}
| _1 = call_expression
    {                   ( _1 )}

conditional_expression:
  _1 = post_in_expression
    {                      ( _1 )}
| _1 = post_in_expression _2 = T_PLING _3 = assignment_expression _4 = T_COLON _5 = assignment_expression
    {     ( e(Conditional (_1, _2, _3, _4, _5)) )}

post_in_expression:
  _1 = pre_in_expression
    {                     ( _1 )}
| _1 = post_in_expression _2 = T_LESS_THAN _3 = post_in_expression
    {                                                              ( bop B_lt _1 _2 _3 )}
| _1 = post_in_expression _2 = T_GREATER_THAN _3 = post_in_expression
    {                                                              ( bop B_gt _1 _2 _3 )}
| _1 = post_in_expression _2 = T_LESS_THAN_EQUAL _3 = post_in_expression
    {                                                              ( bop B_le _1 _2 _3 )}
| _1 = post_in_expression _2 = T_GREATER_THAN_EQUAL _3 = post_in_expression
    {                                                              ( bop B_ge _1 _2 _3 )}
| _1 = post_in_expression _2 = T_INSTANCEOF _3 = post_in_expression
    {                                                              ( bop B_instanceof _1 _2 _3 )}
| _1 = post_in_expression _2 = T_IN _3 = post_in_expression
    {                                                              ( bop B_in _1 _2 _3 )}
| _1 = post_in_expression _2 = T_EQUAL _3 = post_in_expression
    {                                                              ( bop B_equal _1 _2 _3 )}
| _1 = post_in_expression _2 = T_NOT_EQUAL _3 = post_in_expression
    {                                                              ( bop B_notequal _1 _2 _3 )}
| _1 = post_in_expression _2 = T_STRICT_EQUAL _3 = post_in_expression
    {                                                              ( bop B_physequal _1 _2 _3 )}
| _1 = post_in_expression _2 = T_STRICT_NOT_EQUAL _3 = post_in_expression
    {                                                              ( bop B_physnotequal _1 _2 _3 )}
| _1 = post_in_expression _2 = T_BIT_AND _3 = post_in_expression
    {                                                              ( bop B_bitand _1 _2 _3 )}
| _1 = post_in_expression _2 = T_BIT_XOR _3 = post_in_expression
    {                                                              ( bop B_bitxor _1 _2 _3 )}
| _1 = post_in_expression _2 = T_BIT_OR _3 = post_in_expression
    {                                                              ( bop B_bitor _1 _2 _3 )}
| _1 = post_in_expression _2 = T_AND _3 = post_in_expression
    {                                                              ( bop B_and _1 _2 _3 )}
| _1 = post_in_expression _2 = T_OR _3 = post_in_expression
    {                                                              ( bop B_or _1 _2 _3 )}

pre_in_expression:
  _1 = left_hand_side_expression
    {                                                 ( _1 )}
| _1 = pre_in_expression _2 = T_INCR %prec p_POSTFIX
    {                                                 ( uop U_post_increment _2 _1 )}
| _1 = pre_in_expression _2 = T_DECR %prec p_POSTFIX
    {                                                 ( uop U_post_decrement _2 _1 )}
| _1 = T_DELETE _2 = pre_in_expression
    {                                                 ( uop U_delete _1 _2 )}
| _1 = T_VOID _2 = pre_in_expression
    {                                                 ( uop U_void _1 _2 )}
| _1 = T_TYPEOF _2 = pre_in_expression
    {                                                 ( uop U_typeof _1 _2 )}
| _1 = T_INCR _2 = pre_in_expression
    {                                                 ( uop U_pre_increment _1 _2 )}
| _1 = T_DECR _2 = pre_in_expression
    {                                                 ( uop U_pre_decrement _1 _2 )}
| _1 = T_PLUS _2 = pre_in_expression
    {                                                 ( uop U_plus _1 _2 )}
| _1 = T_MINUS _2 = pre_in_expression
    {                                                 ( uop U_minus _1 _2)}
| _1 = T_BIT_NOT _2 = pre_in_expression
    {                                                 ( uop U_bitnot _1 _2 )}
| _1 = T_NOT _2 = pre_in_expression
    {                                                 ( uop U_not _1 _2 )}
| _1 = pre_in_expression _2 = T_MULT _3 = pre_in_expression
    {                                                 ( bop B_mul _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_DIV _3 = pre_in_expression
    {                                                 ( bop B_div _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_MOD _3 = pre_in_expression
    {                                                 ( bop B_mod _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_PLUS _3 = pre_in_expression
    {                                                 ( bop B_add _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_MINUS _3 = pre_in_expression
    {                                                 ( bop B_sub _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_LSHIFT _3 = pre_in_expression
    {                                                 ( bop B_lsl _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_RSHIFT _3 = pre_in_expression
    {                                                 ( bop B_lsr _1 _2 _3 )}
| _1 = pre_in_expression _2 = T_RSHIFT3 _3 = pre_in_expression
    {                                                 ( bop B_asr _1 _2 _3 )}

call_expression:
  _1 = member_expression _2 = arguments
    {                                                    ( e(Apply (_1, _2)) )}
| _1 = call_expression _2 = arguments
    {                                                    ( e(Apply (_1, _2)) )}
| _1 = call_expression _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {                                                    ( e(Bracket(_1, (_2, _3, _4))) )}
| _1 = call_expression _2 = T_PERIOD _3 = method_name
    {                                                     ( e(Period (_1, _2, _3)) )}

new_expression:
  _1 = member_expression
    {                        ( _1 )}
| _1 = T_NEW _2 = new_expression
    {                        ( uop U_new _1 _2 )}

member_expression:
  _1 = primary_expression
    {                                                      ( _1 )}
| _1 = member_expression _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {                                                      ( e(Bracket(_1, (_2, _3, _4))) )}
| _1 = member_expression _2 = T_PERIOD _3 = field_name
    {                                                      ( e(Period (_1, _2, _3)) )}
| _1 = T_NEW _2 = member_expression _3 = arguments
    {     ( e(Apply(uop U_new _1 _2, _3)) )}

primary_expression:
  _1 = primary_expression_no_statement
    {                                   ( _1 )}
| _1 = object_literal
    {                                   ( e(Object _1) )}
| _1 = function_expression
    {                                   ( _1 )}

primary_expression_no_statement:
  _1 = T_THIS
    {                   ( e((This _1)) )}
| _1 = identifier
    {                   ( e((V _1)) )}
| _1 = null_literal
    {                   ( e(L(Null _1)) )}
| _1 = boolean_literal
    {                   ( e(L(Bool _1)) )}
| _1 = numeric_literal
    {                   ( e(L(Num _1)) )}
| _1 = string_literal
    {                   ( e(L(String _1)) )}
| _1 = regex_literal
    {                                ( e(L(Regexp _1)) )}
| _1 = array_literal
    {                                ( e(_1) )}
| _1 = T_LPAREN _2 = expression _3 = T_RPAREN
    {                                ( e(Paren (_1, _2, _3)) )}
| _1 = xhp_html
    {            ( XhpHtml _1 )}
| _1 = T_BACKQUOTE _2 = encaps_list_opt _3 = T_BACKQUOTE
    {     ( Encaps (None, _1, _2, _3) )}
| _1 = identifier _2 = T_BACKQUOTE _3 = encaps_list_opt _4 = T_BACKQUOTE
    {     ( Encaps (Some _1, _2, _3, _4) )}

null_literal:
  _1 = T_NULL
    {          ( _1 )}

boolean_literal:
  _1 = T_TRUE
    {           ( true, _1 )}
| _1 = T_FALSE
    {           ( false, _1 )}

numeric_literal:
  _1 = T_NUMBER
    {            ( _1 )}

regex_literal:
  _1 = T_REGEX
    {           ( _1 )}

string_literal:
  _1 = T_STRING
    {            ( _1 )}

array_literal:
  _1 = T_LBRACKET _2 = elison _3 = T_RBRACKET
    {                                             ( Array(_1, _2, _3) )}
| _1 = T_LBRACKET _2 = T_RBRACKET
    {                                             ( Array(_1, [], _2) )}
| _1 = T_LBRACKET _2 = element_list _3 = T_RBRACKET
    {                                             ( Array(_1, _2, _3) )}
| _1 = T_LBRACKET _2 = element_list _3 = elison _4 = T_RBRACKET
    {                                             ( Array(_1, _2 @ _3, _4) )}

element_list:
  _1 = element_list_rev
    {                               ( List.rev _1 )}

element_list_rev:
  _1 = elison _2 = assignment_expression
    {                                  ( (Left _2)::_1 )}
| _1 = assignment_expression
    {                                  ( [Left _1] )}
| _1 = element_list_rev _2 = elison _3 = assignment_expression
    {                                                     ( [Left _3] @ _2 @ _1 )}

object_literal:
  _1 = T_LCURLY _2 = T_RCURLY
    {     ( (_1, [], _2) )}
| _1 = T_LCURLY _2 = property_name_and_value_list _3 = T_VIRTUAL_SEMICOLON _4 = T_RCURLY
    {     ( (_1, _2, _4) )}
| _1 = T_LCURLY _2 = property_name_and_value_list _3 = T_COMMA _4 = T_VIRTUAL_SEMICOLON _5 = T_RCURLY
    {     ( (_1, _2 @ [Right _3], _5) )}

property_name_and_value:
  _1 = property_name _2 = T_COLON _3 = assignment_expression
    {     ( Left (P_field (_1, _2, _3)) )}
| _1 = method_definition
    {     ( Left (P_method (_1)) )}

property_name_and_value_list:
  _1 = property_name_and_value
    {     ( [_1] )}
| _1 = property_name_and_value_list _2 = T_COMMA _3 = property_name_and_value
    {     ( _1 @ [Right _2; _3] )}

arguments:
  _1 = T_LPAREN _2 = T_RPAREN
    {                                   ( (_1, [], _2) )}
| _1 = T_LPAREN _2 = argument_list _3 = T_RPAREN
    {                                   ( (_1, _2, _3) )}

argument_list:
  _1 = T_DOTS _2 = assignment_expression
    {     ( [Left (uop U_spread _1 _2)] )}
| _1 = assignment_expression
    {     ( [Left _1] )}
| _1 = assignment_expression _2 = T_COMMA _3 = argument_list
    {     ( (Left _1)::(Right _2)::_3 )}

xhp_html:
  _1 = T_XHP_OPEN_TAG _2 = xhp_attributes _3 = T_XHP_GT _4 = xhp_children _5 = T_XHP_CLOSE_TAG
    {     ( Xhp (_1, _2, _3, _4, _5)  )}
| _1 = T_XHP_OPEN_TAG _2 = xhp_attributes _3 = T_XHP_SLASH_GT
    {     ( XhpSingleton (_1, _2, _3) )}

xhp_child:
  _1 = T_XHP_TEXT
    {                        ( XhpText _1 )}
| _1 = xhp_html
    {                        ( XhpNested _1 )}
| _1 = T_LCURLY _2 = expression _3 = semicolon _4 = T_RCURLY
    {     ( XhpExpr (_1, Some _2, _4) (*TODO$3*) )}
| _1 = T_LCURLY _2 = T_RCURLY
    {     ( XhpExpr (_1, None , _2) (*TODO$3*) )}

xhp_attribute:
  _1 = T_XHP_ATTR _2 = T_ASSIGN _3 = xhp_attribute_value
    {                                           ( _1, _2, _3 )}

xhp_attribute_value:
  _1 = T_STRING
    {            ( XhpAttrString (_1) )}
| _1 = T_LCURLY _2 = expression _3 = semicolon _4 = T_RCURLY
    {                                             ( XhpAttrExpr (_1, _2, _4)(*TODO$3*) )}

encaps:
  _1 = T_ENCAPSED_STRING
    {                     ( EncapsString _1 )}
| _1 = T_DOLLARCURLY _2 = expression _3 = T_VIRTUAL_SEMICOLON _4 = T_RCURLY
    {     ( EncapsExpr (_1, _2, _4) )}

arrow_function:
  _1 = identifier _2 = T_ARROW _3 = arrow_body
    {     ( { a_params = ASingleParam (mk_param _1); a_return_type = None;
         a_tok = _2; a_body = _3 } )}
| _1 = T_LPAREN _2 = T_RPAREN _3 = annotation_opt _4 = T_ARROW _5 = arrow_body
    {     ( { a_params = AParams (_1, [], _2); a_return_type = _3;
         a_tok = _4; a_body = _5 } )}
| _1 = T_LPAREN _2 = expression _3 = T_RPAREN _4 = T_ARROW _5 = arrow_body
    {     ( let param =
         match _2 with
         | V name -> mk_param name
         | _ -> raise (Parsing.Parse_error)
       in
       { a_params = AParams (_1, [Left param], _3); a_return_type = None;
         a_tok = _4; a_body = _5 }
     )}
| _1 = T_LPAREN _2 = identifier _3 = annotation _4 = T_RPAREN _5 = annotation_opt _6 = T_ARROW _7 = arrow_body
    {     ( let param = { (mk_param _2) with p_type = Some _3; } in
       let params = AParams (_1, [Left param], _4) in
       { a_params = params; a_return_type = _5; a_tok = _6; a_body = _7 }
     )}
| _1 = T_LPAREN _2 = formal_rest_parameter _3 = T_RPAREN _4 = annotation_opt _5 = T_ARROW _6 = arrow_body
    {     ( let param = _2 in
       { a_params = AParams (_1, [Left param], _3); a_return_type = _4;
         a_tok = _5; a_body = _6 }
     )}
| _1 = T_LPAREN _2 = identifier _3 = T_COMMA _4 = formal_parameter_list _5 = T_RPAREN _6 = annotation_opt _7 = T_ARROW _8 = arrow_body
    {     ( let param = mk_param _2 in
       let params = AParams (_1, (Left param)::Right _3::_4, _5) in
       { a_params = params; a_return_type = _6; a_tok = _7; a_body = _8 }
     )}
| _1 = T_LPAREN _2 = identifier _3 = annotation _4 = T_COMMA _5 = formal_parameter_list _6 = T_RPAREN _7 = annotation_opt _8 = T_ARROW _9 = arrow_body
    {     ( let param = { (mk_param _2) with p_type = Some _3; } in
       let params = AParams (_1, (Left param)::Right _4::_5, _6) in
       { a_params = params; a_return_type = _7; a_tok = _8; a_body = _9 }
     )}

arrow_body:
  _1 = block
    {     ( match _1 with Block (a,b,c) -> ABody (a,b,c) | _ -> raise Impossible )}
| _1 = assignment_expression_no_statement %prec LOW_PRIORITY_RULE
    {                                                              ( AExpr _1 )}

expression_no_in:
  _1 = assignment_expression_no_in
    {                               ( _1 )}
| _1 = expression_no_in _2 = T_COMMA _3 = assignment_expression_no_in
    {                                                        ( e(Seq (_1, _2, _3)) )}

assignment_expression_no_in:
  _1 = conditional_expression_no_in
    {                                ( _1 )}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression_no_in
    {     ( e(Assign (_1, _2, _3)) )}

conditional_expression_no_in:
  _1 = post_in_expression_no_in
    {                            ( _1 )}
| _1 = post_in_expression_no_in _2 = T_PLING _3 = assignment_expression_no_in _4 = T_COLON _5 = assignment_expression_no_in
    {     ( e(Conditional (_1, _2, _3, _4, _5)) )}

post_in_expression_no_in:
  _1 = pre_in_expression
    {                     ( _1 )}
| _1 = post_in_expression_no_in _2 = T_LESS_THAN _3 = post_in_expression
    {                                                                    ( bop B_lt _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_GREATER_THAN _3 = post_in_expression
    {                                                                    ( bop B_gt _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_LESS_THAN_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_le _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_GREATER_THAN_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_ge _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_INSTANCEOF _3 = post_in_expression
    {                                                                    ( bop B_instanceof _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_equal _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_NOT_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_notequal _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_STRICT_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_physequal _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_STRICT_NOT_EQUAL _3 = post_in_expression
    {                                                                    ( bop B_physnotequal _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_BIT_AND _3 = post_in_expression
    {                                                                    ( bop B_bitand _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_BIT_XOR _3 = post_in_expression
    {                                                                    ( bop B_bitxor _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_BIT_OR _3 = post_in_expression
    {                                                                    ( bop B_bitor _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_AND _3 = post_in_expression
    {                                                                    ( bop B_and _1 _2 _3 )}
| _1 = post_in_expression_no_in _2 = T_OR _3 = post_in_expression
    {                                                                    ( bop B_or _1 _2 _3 )}

expression_no_statement:
  _1 = assignment_expression_no_statement
    {                                      ( _1 )}
| _1 = expression_no_statement _2 = T_COMMA _3 = assignment_expression
    {                                                         ( e(Seq (_1, _2, _3)) )}

assignment_expression_no_statement:
  _1 = conditional_expression_no_statement
    {                                       ( _1 )}
| _1 = left_hand_side_expression_no_statement _2 = assignment_operator _3 = assignment_expression
    {     ( e(Assign (_1, _2, _3)) )}

conditional_expression_no_statement:
  _1 = post_in_expression_no_statement
    {                                   ( _1 )}
| _1 = post_in_expression_no_statement _2 = T_PLING _3 = assignment_expression _4 = T_COLON _5 = assignment_expression
    {     ( e(Conditional (_1, _2, _3, _4, _5)) )}

post_in_expression_no_statement:
  _1 = pre_in_expression_no_statement
    {                                  ( _1 )}
| _1 = post_in_expression_no_statement _2 = T_LESS_THAN _3 = post_in_expression
    {                                                                           ( bop B_lt _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_GREATER_THAN _3 = post_in_expression
    {                                                                           ( bop B_gt _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_LESS_THAN_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_le _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_GREATER_THAN_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_ge _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_INSTANCEOF _3 = post_in_expression
    {                                                                           ( bop B_instanceof _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_IN _3 = post_in_expression
    {                                                                           ( bop B_in _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_equal _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_NOT_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_notequal _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_STRICT_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_physequal _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_STRICT_NOT_EQUAL _3 = post_in_expression
    {                                                                           ( bop B_physnotequal _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_BIT_AND _3 = post_in_expression
    {                                                                           ( bop B_bitand _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_BIT_XOR _3 = post_in_expression
    {                                                                           ( bop B_bitxor _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_BIT_OR _3 = post_in_expression
    {                                                                           ( bop B_bitor _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_AND _3 = post_in_expression
    {                                                                           ( bop B_and _1 _2 _3 )}
| _1 = post_in_expression_no_statement _2 = T_OR _3 = post_in_expression
    {                                                                           ( bop B_or _1 _2 _3 )}

pre_in_expression_no_statement:
  _1 = left_hand_side_expression_no_statement
    {                                                              ( _1 )}
| _1 = pre_in_expression_no_statement _2 = T_INCR
    {                                                              ( uop U_post_increment _2 _1 )}
| _1 = pre_in_expression_no_statement _2 = T_DECR
    {                                                              ( uop U_post_decrement _2 _1 )}
| _1 = T_DELETE _2 = pre_in_expression
    {                                                              ( uop U_delete _1 _2 )}
| _1 = T_VOID _2 = pre_in_expression
    {                                                              ( uop U_void _1 _2 )}
| _1 = T_TYPEOF _2 = pre_in_expression
    {                                                              ( uop U_typeof _1 _2 )}
| _1 = T_INCR _2 = pre_in_expression
    {                                                              ( uop U_pre_increment _1 _2 )}
| _1 = T_DECR _2 = pre_in_expression
    {                                                              ( uop U_pre_decrement _1 _2 )}
| _1 = T_PLUS _2 = pre_in_expression
    {                                                              ( uop U_plus _1 _2 )}
| _1 = T_MINUS _2 = pre_in_expression
    {                                                              ( uop U_minus _1 _2)}
| _1 = T_BIT_NOT _2 = pre_in_expression
    {                                                              ( uop U_bitnot _1 _2 )}
| _1 = T_NOT _2 = pre_in_expression
    {                                                              ( uop U_not _1 _2 )}
| _1 = pre_in_expression_no_statement _2 = T_MULT _3 = pre_in_expression
    {                                                              ( bop B_mul _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_DIV _3 = pre_in_expression
    {                                                              ( bop B_div _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_MOD _3 = pre_in_expression
    {                                                              ( bop B_mod _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_PLUS _3 = pre_in_expression
    {                                                              ( bop B_add _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_MINUS _3 = pre_in_expression
    {                                                              ( bop B_sub _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_LSHIFT _3 = pre_in_expression
    {                                                              ( bop B_lsl _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_RSHIFT _3 = pre_in_expression
    {                                                              ( bop B_lsr _1 _2 _3 )}
| _1 = pre_in_expression_no_statement _2 = T_RSHIFT3 _3 = pre_in_expression
    {                                                              ( bop B_asr _1 _2 _3 )}

left_hand_side_expression_no_statement:
  _1 = new_expression_no_statement
    {                               ( _1 )}
| _1 = call_expression_no_statement
    {                                ( _1 )}

new_expression_no_statement:
  _1 = member_expression_no_statement
    {                                  ( _1 )}
| _1 = T_NEW _2 = new_expression
    {                        ( uop U_new _1 _2 )}

call_expression_no_statement:
  _1 = member_expression_no_statement _2 = arguments
    {                                                                 ( e(Apply (_1, _2)) )}
| _1 = call_expression_no_statement _2 = arguments
    {                                                                 ( e(Apply (_1, _2)) )}
| _1 = call_expression_no_statement _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {                                                                 ( e(Bracket(_1, (_2, _3, _4))) )}
| _1 = call_expression_no_statement _2 = T_PERIOD _3 = method_name
    {                                                                  ( e(Period (_1, _2, _3)) )}

member_expression_no_statement:
  _1 = primary_expression_no_statement
    {                                                                   ( _1 )}
| _1 = member_expression_no_statement _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {                                                                   ( e(Bracket(_1, (_2, _3, _4))) )}
| _1 = member_expression_no_statement _2 = T_PERIOD _3 = field_name
    {                                                                   ( e(Period (_1, _2, _3)) )}
| _1 = T_NEW _2 = member_expression _3 = arguments
    {                                                                   ( e(Apply(uop U_new _1 _2, _3)) )}

identifier:
  _1 = T_IDENTIFIER
    {                ( _1 )}

field_name:
  _1 = T_IDENTIFIER
    {                ( _1 )}
| _1 = T_CLASS
    {           ( "class", _1 )}

method_name:
  _1 = T_IDENTIFIER
    {                ( _1 )}
| _1 = T_DEFAULT
    {             ( "default", _1 )}

property_name:
  _1 = T_IDENTIFIER
    {                   ( PN_String _1 )}
| _1 = string_literal
    {                   ( PN_String _1 )}
| _1 = numeric_literal
    {                   ( PN_Num _1 )}
| _1 = T_CLASS
    {                   ( PN_String ("class", _1) )}

semicolon:
  _1 = T_SEMICOLON
    {                       ( Some _1 )}
| _1 = T_VIRTUAL_SEMICOLON
    {                       ( None )}

elison:
  _1 = T_COMMA
    {           ( [Right _1] )}
| _1 = elison _2 = T_COMMA
    {                  ( _1 @ [Right _2] )}

statement_list:
  _1 = source_element
    {                  ( [_1] )}
| _1 = statement_list _2 = source_element
    {                                 ( _1 @ [_2] )}

class_element_list:
  _1 = class_element
    {                 ( [_1] )}
| _1 = class_element_list _2 = class_element
    {                                    ( _1 @ [_2] )}

encaps_list:
  _1 = encaps
    {          ( [_1] )}
| _1 = encaps_list _2 = encaps
    {                      ( _1 @ [_2] )}

case_clauses:
  _1 = case_clause
    {               ( [_1] )}
| _1 = case_clauses _2 = case_clause
    {                            ( _1 @ [_2] )}

xhp_attributes:
  
    {                 ( [] )}
| _1 = xhp_attributes _2 = xhp_attribute
    {                                ( _1 @ [_2] )}

xhp_children:
  
    {                 ( [] )}
| _1 = xhp_children _2 = xhp_child
    {                          ( _1 @ [_2] )}

variable_declaration_list:
  _1 = variable_declaration
    {     ( [Left _1]  )}
| _1 = variable_declaration_list _2 = T_COMMA _3 = variable_declaration
    {     ( _1 @ [Right _2; Left _3] )}

variable_declaration_list_no_in:
  _1 = variable_declaration_no_in
    {     ( [Left _1] )}
| _1 = variable_declaration_list_no_in _2 = T_COMMA _3 = variable_declaration_no_in
    {     ( _1 @ [Right _2; Left _3] )}

expression_opt:
  
    {                   ( None )}
| _1 = expression
    {                   ( Some _1 )}

expression_no_in_opt:
  
    {                    ( None )}
| _1 = expression_no_in
    {                    ( Some _1 )}

class_heritage_opt:
  
    {                   ( None )}
| _1 = class_heritage
    {                  ( Some _1 )}

class_body_opt:
  
    {                   ( [] )}
| _1 = class_body
    {              ( _1 )}

formal_parameter_list_opt:
  
    {                   ( [] )}
| _1 = formal_parameter_list
    {                         ( _1 )}

case_clauses_opt:
  
    {                   ( [] )}
| _1 = case_clauses
    {                   ( _1 )}

encaps_list_opt:
  
    {                   ( [] )}
| _1 = encaps_list
    {                  ( _1 )}

annotation_opt:
  
    {                   ( None )}
| _1 = annotation
    {                 ( Some _1 )}

generics_opt:
  
    {                   ( None )}
| _1 = generics
    {                   ( Some _1 )}

identifier_opt:
  
    {                   ( None )}
| _1 = identifier
    {              ( Some _1 )}

initializeur_opt:
  
    {                   ( None )}
| _1 = initializeur
    {                ( Some _1 )}

field_type_list_opt:
  
    {                   ( [] )}
| _1 = field_type_list
    {                   ( _1 )}

param_type_list_opt:
  
    {                   ( [] )}
| _1 = param_type_list
    {                   ( _1 )}

%%


