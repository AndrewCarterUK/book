File "parser_java.mly", line 186, characters 10-17:
Warning: the token BOOLEAN is unused.
File "parser_java.mly", line 186, characters 24-28:
Warning: the token BYTE is unused.
File "parser_java.mly", line 186, characters 40-44:
Warning: the token CHAR is unused.
File "parser_java.mly", line 186, characters 51-56:
Warning: the token CONST is unused.
File "parser_java.mly", line 187, characters 12-18:
Warning: the token DOUBLE is unused.
File "parser_java.mly", line 187, characters 46-51:
Warning: the token FLOAT is unused.
File "parser_java.mly", line 187, characters 56-60:
Warning: the token GOTO is unused.
File "parser_java.mly", line 188, characters 33-36:
Warning: the token INT is unused.
File "parser_java.mly", line 188, characters 47-51:
Warning: the token LONG is unused.
File "parser_java.mly", line 190, characters 1-6:
Warning: the token SHORT is unused.
File "parser_java.mly", line 110, characters 25-33:
Warning: the token TComment is unused.
File "parser_java.mly", line 110, characters 34-49:
Warning: the token TCommentNewline is unused.
File "parser_java.mly", line 110, characters 50-63:
Warning: the token TCommentSpace is unused.
File "parser_java.mly", line 201, characters 25-33:
Warning: the token TUnknown is unused.
%{
open Common
open Ast_java

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(* todo? use a Ast.special? *)
let this_ident ii = [], ("this", ii)
let super_ident ii = [], ("super", ii)
let super_identifier ii = ("super", ii)

let named_type (str, ii) = TBasic (str,ii)
let void_type ii = named_type ("void", ii)

(* we have to use a 'name' to specify reference types in the grammar
 * because of some ambiguity but what we really wanted was an
 * identifier followed by some type arguments.
 *)
let (class_type: name_or_class_type -> class_type) = fun xs ->
  xs +> List.map (function
  | Id x -> x, []
  | Id_then_TypeArgs (x, xs) -> x, xs
  | TypeArgs_then_Id _ -> raise Parsing.Parse_error
  )

let (name: name_or_class_type -> name) = fun xs ->
  xs +> List.map (function
  | Id x -> [], x
  | Id_then_TypeArgs (x, xs) ->
      (* this is ok because of the ugly trick we do for Cast
       * where we transform a Name into a ref_type
       *)
      xs, x
  | TypeArgs_then_Id (xs, Id x) ->
      xs, x
  | TypeArgs_then_Id (_xs, _) ->
      raise Parsing.Parse_error
  )

let (qualified_ident: name_or_class_type -> qualified_ident) = fun xs ->
  xs +> List.map (function
  | Id x -> x
  | Id_then_TypeArgs _ -> raise Parsing.Parse_error
  | TypeArgs_then_Id _ -> raise Parsing.Parse_error
  )

type var_decl_id =
  | IdentDecl of ident
  | ArrayDecl of var_decl_id

(* Move array dimensions from variable name to type. *)
let rec canon_var mods t v =
  match v with
  | IdentDecl str -> { v_mods = mods; v_type = t; v_name = str }
  | ArrayDecl v' -> canon_var mods (TArray t) v'

let method_header mods mtype (v, formals) throws =
  { m_var = canon_var mods mtype v; m_formals = formals;
    m_throws = throws; m_body = Empty }

(* Return a list of field declarations in canonical form. *)

let decls f = fun mods vtype vars ->
  let dcl (v, init) =
    f { f_var = canon_var mods vtype v; f_init = init }
  in
  List.map dcl vars

let constructor_invocation name args =
  Expr (Call ((Name name), args))

%}
%start goal
%token <Parse_info.info> ABSTRACT
%token <Parse_info.info> AND
%token <Parse_info.info> AND_AND
%token <Parse_info.info> ASSERT
%token <Parse_info.info> AT
%token <Parse_info.info> BOOLEAN
%token <Parse_info.info> BREAK
%token <Parse_info.info> BYTE
%token <Parse_info.info> CASE
%token <Parse_info.info> CATCH
%token <Parse_info.info> CHAR
%token <Parse_info.info> CLASS
%token <Parse_info.info> CM
%token <Parse_info.info> COLON
%token <Parse_info.info> COMPL
%token <Parse_info.info> COND
%token <Parse_info.info> CONST
%token <Parse_info.info> CONTINUE
%token <Parse_info.info> DECR
%token <Parse_info.info> DEFAULT
%token <Parse_info.info> DIV
%token <Parse_info.info> DO
%token <Parse_info.info> DOT
%token <Parse_info.info> DOTS
%token <Parse_info.info> DOUBLE
%token <Parse_info.info> ELSE
%token <Parse_info.info> ENUM
%token <Parse_info.info> EOF
%token <Parse_info.info> EQ
%token <Parse_info.info> EQ_EQ
%token <Parse_info.info> EXTENDS
%token <Parse_info.info> FINAL
%token <Parse_info.info> FINALLY
%token <Parse_info.info> FLOAT
%token <Parse_info.info> FOR
%token <Parse_info.info> GE
%token <Parse_info.info> GOTO
%token <Parse_info.info> GT
%token <(string * Parse_info.info)> IDENTIFIER
%token <Parse_info.info> IF
%token <Parse_info.info> IMPLEMENTS
%token <Parse_info.info> IMPORT
%token <Parse_info.info> INCR
%token <Parse_info.info> INSTANCEOF
%token <Parse_info.info> INT
%token <Parse_info.info> INTERFACE
%token <Parse_info.info> LB
%token <Parse_info.info> LB_RB
%token <Parse_info.info> LC
%token <Parse_info.info> LE
%token <(string * Parse_info.info)> LITERAL
%token <Parse_info.info> LONG
%token <Parse_info.info> LP
%token <Parse_info.info> LS
%token <Parse_info.info> LT
%token <Parse_info.info> LT2
%token <Parse_info.info> MINUS
%token <Parse_info.info> MOD
%token <Parse_info.info> NATIVE
%token <Parse_info.info> NEW
%token <Parse_info.info> NOT
%token <Parse_info.info> NOT_EQ
%token <(string * Parse_info.info)> OPERATOR_EQ
%token <Parse_info.info> OR
%token <Parse_info.info> OR_OR
%token <Parse_info.info> PACKAGE
%token <Parse_info.info> PLUS
%token <(string * Parse_info.info)> PRIMITIVE_TYPE
%token <Parse_info.info> PRIVATE
%token <Parse_info.info> PROTECTED
%token <Parse_info.info> PUBLIC
%token <Parse_info.info> RB
%token <Parse_info.info> RC
%token <Parse_info.info> RETURN
%token <Parse_info.info> RP
%token <Parse_info.info> SHORT
%token <Parse_info.info> SM
%token <Parse_info.info> SRS
%token <Parse_info.info> STATIC
%token <Parse_info.info> STRICTFP
%token <Parse_info.info> SUPER
%token <Parse_info.info> SWITCH
%token <Parse_info.info> SYNCHRONIZED
%token <string * Parse_info.info> TChar
%token <Parse_info.info> TComment
%token <Parse_info.info> TCommentNewline
%token <Parse_info.info> TCommentSpace
%token <string * Parse_info.info> TFloat
%token <Parse_info.info> THIS
%token <Parse_info.info> THROW
%token <Parse_info.info> THROWS
%token <Parse_info.info> TIMES
%token <string * Parse_info.info> TInt
%token <Parse_info.info> TRANSIENT
%token <Parse_info.info> TRY
%token <string * Parse_info.info> TString
%token <Parse_info.info> TUnknown
%token <Parse_info.info> URS
%token <Parse_info.info> VOID
%token <Parse_info.info> VOLATILE
%token <Parse_info.info> WHILE
%token <Parse_info.info> XOR
%type <Ast_java.program> goal
%%

goal:
  _1 = compilation_unit _2 = EOF
    {                            ( _1 )}

compilation_unit:
  _1 = package_declaration_opt _2 = import_declarations_opt _3 = type_declarations_opt
    {  ( { package = _1; imports = _2; decls = _3; } )}

package_declaration:
  _1 = PACKAGE _2 = name _3 = SM
    {                                      ( qualified_ident _2 )}

import_declaration:
  _1 = IMPORT _2 = static_opt _3 = name _4 = SM
    {                                        ( _2, qualified_ident _3 )}
| _1 = IMPORT _2 = static_opt _3 = name _4 = DOT _5 = TIMES _6 = SM
    {                                        ( _2, (qualified_ident _3 @["*", _5]))}

type_declaration:
  _1 = class_declaration
    {                          ( [Class _1] )}
| _1 = interface_declaration
    {                          ( [Class _1] )}
| _1 = enum_declaration
    {                               ( [Enum _1] )}
| _1 = annotation_type_declaration
    {                               ( ast_todo )}
| _1 = SM
    {       ( [] )}

identifier:
  _1 = IDENTIFIER
    {                       ( _1 )}

name:
  _1 = identifier_
    {                         ( [_1] )}
| _1 = name _2 = DOT _3 = identifier_
    {                         ( _1 @ [_3] )}
| _1 = name _2 = DOT _3 = LT2 _4 = type_arguments _5 = GT _6 = identifier_
    {                                              ( _1@[TypeArgs_then_Id(_4,_6)] )}

identifier_:
  _1 = identifier
    {                                    ( Id _1 )}
| _1 = identifier _2 = LT2 _3 = type_arguments _4 = GT
    {                                    ( Id_then_TypeArgs(_1, _3) )}

type_java:
  _1 = primitive_type
    {                            ( _1 )}
| _1 = class_or_interface_type
    {                            ( _1 )}
| _1 = array_type
    {                            ( _1 )}

primitive_type:
  _1 = PRIMITIVE_TYPE
    {                                ( named_type _1 )}

class_or_interface_type:
  _1 = name
    {                              ( TClass (class_type _1) )}

reference_type:
  _1 = class_or_interface_type
    {                           ( _1 )}
| _1 = array_type
    {              ( _1 )}

array_type:
  _1 = primitive_type _2 = LB_RB
    {                                 ( TArray _1 )}
| _1 = class_or_interface_type _2 = LB_RB
    {                                 ( TArray _1 )}
| _1 = array_type _2 = LB_RB
    {                                 ( TArray _1 )}

type_argument:
  _1 = reference_type
    {                  ( TArgument _1 )}
| _1 = COND
    {                  ( TQuestion None )}
| _1 = COND _2 = EXTENDS _3 = reference_type
    {                               ( TQuestion (Some (false, _3)) )}
| _1 = COND _2 = SUPER _3 = reference_type
    {                               ( TQuestion (Some (true, _3)))}

type_parameter:
  _1 = identifier
    {                            ( TParam (_1, []) )}
| _1 = identifier _2 = EXTENDS _3 = bound
    {                            ( TParam (_1, _3) )}

bound:
  _1 = ref_type_and_list
    {                         ( _1 )}

primary:
  _1 = primary_no_new_array
    {                              ( _1 )}
| _1 = array_creation_expression
    {                              ( _1 )}

primary_no_new_array:
  _1 = literal
    {                       ( _1 )}
| _1 = class_literal
    {                       ( _1 )}
| _1 = THIS
    {                       ( Name [this_ident _1] )}
| _1 = name _2 = DOT _3 = THIS
    {                       ( Name (name _1 @ [this_ident _3]) )}
| _1 = LP _2 = expression _3 = RP
    {                       ( _2 )}
| _1 = class_instance_creation_expression
    {                                      ( _1 )}
| _1 = field_access
    {                                      ( _1 )}
| _1 = method_invocation
    {                                      ( _1 )}
| _1 = array_access
    {                                      ( _1 )}

literal:
  _1 = LITERAL
    {           ( Literal (_1) )}
| _1 = TInt
    {           ( Literal (_1) )}
| _1 = TFloat
    {           ( Literal (_1) )}
| _1 = TChar
    {           ( Literal (_1) )}
| _1 = TString
    {           ( Literal (_1) )}

class_literal:
  _1 = primitive_type _2 = DOT _3 = CLASS
    {                             ( ClassLiteral _1 )}
| _1 = name _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (TClass (class_type (_1))) )}
| _1 = array_type _2 = DOT _3 = CLASS
    {                             ( ClassLiteral _1 )}
| _1 = VOID _2 = DOT _3 = CLASS
    {                             ( ClassLiteral (void_type _1) )}

class_instance_creation_expression:
  _1 = NEW _2 = name _3 = LP _4 = argument_list_opt _5 = RP _6 = class_body_opt
    {       ( NewClass (TClass (class_type _2), _4, _6) )}
| _1 = primary _2 = DOT _3 = NEW _4 = identifier _5 = LP _6 = argument_list_opt _7 = RP _8 = class_body_opt
    {       ( NewQualifiedClass (_1, _4, _6, _8) )}
| _1 = name _2 = DOT _3 = NEW _4 = identifier _5 = LP _6 = argument_list_opt _7 = RP _8 = class_body_opt
    {       ( NewQualifiedClass ((Name (name _1)), _4, _6, _8) )}

array_creation_expression:
  _1 = NEW _2 = primitive_type _3 = dim_exprs _4 = dims_opt
    {       ( NewArray (_2, List.rev _3, _4, None) )}
| _1 = NEW _2 = name _3 = dim_exprs _4 = dims_opt
    {       ( NewArray (TClass (class_type (_2)), List.rev _3, _4, None) )}
| _1 = NEW _2 = primitive_type _3 = dims _4 = array_initializer
    {       ( NewArray (_2, [], _3, Some _4) )}
| _1 = NEW _2 = name _3 = dims _4 = array_initializer
    {       ( NewArray (TClass (class_type (_2)), [], _3, Some _4) )}

dim_expr:
  _1 = LB _2 = expression _3 = RB
    {                            ( _2 )}

dims:
  _1 = LB_RB
    {               ( 1 )}
| _1 = dims _2 = LB_RB
    {               ( _1 + 1 )}

field_access:
  _1 = primary _2 = DOT _3 = identifier
    {                                 ( Dot (_1, _3) )}
| _1 = SUPER _2 = DOT _3 = identifier
    {                                 ( Dot (Name [super_ident _1], _3) )}
| _1 = name _2 = DOT _3 = SUPER _4 = DOT _5 = identifier
    {                                 ( Dot (Name (name _1@[super_ident _3]), _5) )}

array_access:
  _1 = name _2 = LB _3 = expression _4 = RB
    {                                          ( ArrayAccess ((Name (name _1)), _3))}
| _1 = primary_no_new_array _2 = LB _3 = expression _4 = RB
    {                                          ( ArrayAccess (_1, _3) )}

method_invocation:
  _1 = name _2 = LP _3 = argument_list_opt _4 = RP
    {        (
          match List.rev _1 with
          (* TODO: lose information of TypeArgs_then_Id *)
          | ((Id x) | (TypeArgs_then_Id (_, Id x)))::xs ->
              let (xs: identifier_ list) =
                (match xs with
                (* should be a "this" or "self" *)
                | [] -> [Id ("this", fakeInfo "this")]
                | _ -> List.rev xs
                )
              in
              Call (Dot (Name (name (xs)), x), _3)
          | _ ->
              pr2 "method_invocation pb";
              pr2_gen _1;
              raise Impossible
        )}
| _1 = primary _2 = DOT _3 = identifier _4 = LP _5 = argument_list_opt _6 = RP
    { ( Call ((Dot (_1, _3)), _5) )}
| _1 = SUPER _2 = DOT _3 = identifier _4 = LP _5 = argument_list_opt _6 = RP
    { ( Call ((Dot (Name [super_ident _1], _3)), _5) )}
| _1 = name _2 = DOT _3 = SUPER _4 = DOT _5 = identifier _6 = LP _7 = argument_list_opt _8 = RP
    { ( Call (Dot (Name (name _1 @ [super_ident _3]), _5), _7))}

postfix_expression:
  _1 = primary
    {            ( _1 )}
| _1 = name
    {            (
     (* Ambiguity. It could be a field access (Dot) or a qualified
      * name (Name). See ast_java.ml note on the Dot constructor for
      * more information.
      * The last dot has to be a Dot and not a Name at least,
      * but more elements of Name could be a Dot too.
      *)
     match List.rev _1 with
     | (Id id)::x::xs ->
         Dot (Name (name (List.rev (x::xs))), id)
     | _ ->
         Name (name _1)
   )}
| _1 = post_increment_expression
    {                              ( _1 )}
| _1 = post_decrement_expression
    {                              ( _1 )}

post_increment_expression:
  _1 = postfix_expression _2 = INCR
    {                                                    ( Postfix (_1, "++") )}

post_decrement_expression:
  _1 = postfix_expression _2 = DECR
    {                                                    ( Postfix (_1, "--") )}

unary_expression:
  _1 = pre_increment_expression
    {                             ( _1 )}
| _1 = pre_decrement_expression
    {                             ( _1 )}
| _1 = PLUS _2 = unary_expression
    {                          ( Prefix ("+", _2) )}
| _1 = MINUS _2 = unary_expression
    {                           ( Prefix ("-", _2) )}
| _1 = unary_expression_not_plus_minus
    {                                    ( _1 )}

pre_increment_expression:
  _1 = INCR _2 = unary_expression
    {                                                 ( Prefix ("++", _2) )}

pre_decrement_expression:
  _1 = DECR _2 = unary_expression
    {                                                 ( Prefix ("--", _2) )}

unary_expression_not_plus_minus:
  _1 = postfix_expression
    {                       ( _1 )}
| _1 = COMPL _2 = unary_expression
    {                           ( Prefix ("~", _2) )}
| _1 = NOT _2 = unary_expression
    {                           ( Prefix ("!", _2) )}
| _1 = cast_expression
    {                    ( _1 )}

cast_expression:
  _1 = LP _2 = primitive_type _3 = RP _4 = unary_expression
    {                                          ( Cast (_2, _4) )}
| _1 = LP _2 = expression _3 = RP _4 = unary_expression_not_plus_minus
    { (
          let typname =
            match _2 with
            | Name name ->
                TClass (name +> List.map (fun (xs, id) -> id, xs))
            (* ugly, undo what was done in postfix_expression *)
            | Dot (Name name, id) ->
                TClass ((name @ [[], id]) +> List.map (fun (xs, id) -> id, xs))
            | _ ->
                pr2 "cast_expression pb";
                pr2_gen _2;
                raise Todo
          in
          Cast (typname, _4)
        )}
| _1 = LP _2 = array_type _3 = RP _4 = unary_expression_not_plus_minus
    {                                                     ( Cast (_2, _4) )}

multiplicative_expression:
  _1 = unary_expression
    {                     ( _1 )}
| _1 = multiplicative_expression _2 = TIMES _3 = unary_expression
    {                                                    ( Infix (_1, "*", _3) )}
| _1 = multiplicative_expression _2 = DIV _3 = unary_expression
    {                                                    ( Infix (_1, "/", _3) )}
| _1 = multiplicative_expression _2 = MOD _3 = unary_expression
    {                                                    ( Infix (_1, "%", _3) )}

additive_expression:
  _1 = multiplicative_expression
    {                              ( _1 )}
| _1 = additive_expression _2 = PLUS _3 = multiplicative_expression
    {                                                      ( Infix (_1, "+", _3) )}
| _1 = additive_expression _2 = MINUS _3 = multiplicative_expression
    {                                                       ( Infix (_1, "-", _3) )}

shift_expression:
  _1 = additive_expression
    {                        ( _1 )}
| _1 = shift_expression _2 = LS _3 = additive_expression
    {                                            ( Infix (_1, "<<", _3) )}
| _1 = shift_expression _2 = SRS _3 = additive_expression
    {                                             ( Infix (_1, ">>", _3) )}
| _1 = shift_expression _2 = URS _3 = additive_expression
    {                                             ( Infix (_1, ">>>", _3) )}

relational_expression:
  _1 = shift_expression
    {                     ( _1 )}
| _1 = relational_expression _2 = LT _3 = shift_expression
    {                                              ( Infix (_1, "<", _3) )}
| _1 = relational_expression _2 = GT _3 = shift_expression
    {                                              ( Infix (_1, ">", _3) )}
| _1 = relational_expression _2 = LE _3 = shift_expression
    {                                              ( Infix (_1, "<=", _3) )}
| _1 = relational_expression _2 = GE _3 = shift_expression
    {                                              ( Infix (_1, ">=", _3) )}
| _1 = relational_expression _2 = INSTANCEOF _3 = reference_type
    {                                                    ( InstanceOf (_1, _3) )}

equality_expression:
  _1 = relational_expression
    {                          ( _1 )}
| _1 = equality_expression _2 = EQ_EQ _3 = relational_expression
    {                                                    ( Infix (_1, "==", _3) )}
| _1 = equality_expression _2 = NOT_EQ _3 = relational_expression
    {                                                    ( Infix (_1, "!=", _3) )}

and_expression:
  _1 = equality_expression
    {                        ( _1 )}
| _1 = and_expression _2 = AND _3 = equality_expression
    {                                           ( Infix (_1, "&", _3) )}

exclusive_or_expression:
  _1 = and_expression
    {                   ( _1 )}
| _1 = exclusive_or_expression _2 = XOR _3 = and_expression
    {                                               ( Infix (_1, "^", _3) )}

inclusive_or_expression:
  _1 = exclusive_or_expression
    {                            ( _1 )}
| _1 = inclusive_or_expression _2 = OR _3 = exclusive_or_expression
    {                                                       ( Infix (_1, "|", _3) )}

conditional_and_expression:
  _1 = inclusive_or_expression
    {                            ( _1 )}
| _1 = conditional_and_expression _2 = AND_AND _3 = inclusive_or_expression
    {     ( Infix(_1,"&&",_3) )}

conditional_or_expression:
  _1 = conditional_and_expression
    {                               ( _1 )}
| _1 = conditional_or_expression _2 = OR_OR _3 = conditional_and_expression
    {     ( Infix (_1, "||", _3) )}

conditional_expression:
  _1 = conditional_or_expression
    {     ( _1 )}
| _1 = conditional_or_expression _2 = COND _3 = expression _4 = COLON _5 = conditional_expression
    {     ( Conditional (_1, _3, _5) )}

assignment_expression:
  _1 = conditional_expression
    {                           ( _1 )}
| _1 = assignment
    {                           ( _1 )}

assignment:
  _1 = left_hand_side _2 = assignment_operator _3 = assignment_expression
    {    ( Assignment (_1, fst _2, _3) )}

left_hand_side:
  _1 = name
    {                 ( Name (name _1) )}
| _1 = field_access
    {                 ( _1 )}
| _1 = array_access
    {                 ( _1 )}

assignment_operator:
  _1 = EQ
    {       ( "=", _1  )}
| _1 = OPERATOR_EQ
    {                ( _1 )}

expression:
  _1 = assignment_expression
    {                                   ( _1 )}

constant_expression:
  _1 = expression
    {                                 ( _1 )}

statement:
  _1 = statement_without_trailing_substatement
    {                                            ( _1 )}
| _1 = labeled_statement
    {                      ( _1 )}
| _1 = if_then_statement
    {                      ( _1 )}
| _1 = if_then_else_statement
    {                           ( _1 )}
| _1 = while_statement
    {                    ( _1 )}
| _1 = for_statement
    {                  ( _1 )}

statement_without_trailing_substatement:
  _1 = block
    {          ( _1 )}
| _1 = empty_statement
    {                    ( _1 )}
| _1 = expression_statement
    {                         ( _1 )}
| _1 = switch_statement
    {                     ( _1 )}
| _1 = do_statement
    {                 ( _1 )}
| _1 = break_statement
    {                    ( _1 )}
| _1 = continue_statement
    {                       ( _1 )}
| _1 = return_statement
    {                     ( _1 )}
| _1 = synchronized_statement
    {                           ( _1 )}
| _1 = throw_statement
    {                    ( _1 )}
| _1 = try_statement
    {                  ( _1 )}
| _1 = ASSERT _2 = expression _3 = SM
    {                                         ( Assert (_2, None) )}
| _1 = ASSERT _2 = expression _3 = COLON _4 = expression _5 = SM
    {                                         ( Assert (_2, Some _4) )}

block:
  _1 = LC _2 = block_statements_opt _3 = RC
    {                                   ( Block _2 )}

block_statement:
  _1 = local_variable_declaration_statement
    {                                         ( _1 )}
| _1 = class_declaration
    {                      ( [LocalClass _1] )}
| _1 = statement
    {                      ( [_1] )}

local_variable_declaration_statement:
  _1 = local_variable_declaration _2 = SM
    { ( List.map (fun x -> LocalVar x) _1 )}

local_variable_declaration:
  _1 = type_java _2 = variable_declarators
    {     ( decls (fun x -> x) [] _1 (List.rev _2) )}
| _1 = modifiers _2 = type_java _3 = variable_declarators
    {     ( decls (fun x -> x) _1 _2 (List.rev _3) )}

empty_statement:
  _1 = SM
    {                    ( Empty )}

labeled_statement:
  _1 = identifier _2 = COLON _3 = statement
    {   ( Label (_1, _3) )}

expression_statement:
  _1 = statement_expression _2 = SM
    {                                               ( Expr _1 )}

statement_expression:
  _1 = assignment
    {               ( _1 )}
| _1 = pre_increment_expression
    {                             ( _1 )}
| _1 = pre_decrement_expression
    {                             ( _1 )}
| _1 = post_increment_expression
    {                              ( _1 )}
| _1 = post_decrement_expression
    {                              ( _1 )}
| _1 = method_invocation
    {                      ( _1 )}
| _1 = class_instance_creation_expression
    {                                       ( _1 )}

if_then_statement:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement
    {   ( If (_3, _5, Empty) )}

if_then_else_statement:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if _6 = ELSE _7 = statement
    {   ( If (_3, _5, _7) )}

switch_statement:
  _1 = SWITCH _2 = LP _3 = expression _4 = RP _5 = switch_block
    {    ( Switch (_3, _5) )}

switch_block:
  _1 = LC _2 = RC
    {          ( [] )}
| _1 = LC _2 = switch_labels _3 = RC
    {                        ( [_2, []] )}
| _1 = LC _2 = switch_block_statement_groups _3 = RC
    {                                        ( List.rev _2 )}
| _1 = LC _2 = switch_block_statement_groups _3 = switch_labels _4 = RC
    {     ( List.rev ((List.rev _3, []) :: _2) )}

switch_block_statement_group:
  _1 = switch_labels _2 = block_statements
    {                                                              (List.rev _1, _2)}

switch_label:
  _1 = CASE _2 = constant_expression _3 = COLON
    {                                   ( Case _2 )}
| _1 = DEFAULT _2 = COLON
    {                                   ( Default )}

while_statement:
  _1 = WHILE _2 = LP _3 = expression _4 = RP _5 = statement
    {     ( While (_3, _5) )}

do_statement:
  _1 = DO _2 = statement _3 = WHILE _4 = LP _5 = expression _6 = RP _7 = SM
    {     ( Do (_2, _5) )}

for_statement:
  _1 = FOR _2 = LP _3 = for_control _4 = RP _5 = statement
    { ( For (_3, _5) )}

for_control:
  _1 = for_init_opt _2 = SM _3 = expression_opt _4 = SM _5 = for_update_opt
    {     ( ForClassic (_1, Common2.option_to_list _3, _5) )}
| _1 = for_var_control
    {     ( let (a, b) = _1 in Foreach (a, b) )}

for_init_opt:
  
    {                  ( ForInitExprs [] )}
| _1 = for_init
    {                  ( _1 )}

for_init:
  _1 = statement_expression_list
    {                              ( ForInitExprs _1 )}
| _1 = local_variable_declaration
    {                              ( ForInitVars _1 )}

for_update:
  _1 = statement_expression_list
    {                                       ( _1 )}

for_var_control:
  _1 = type_java _2 = variable_declarator_id _3 = for_var_control_rest
    {     (  canon_var [] _1 _2, _3 )}
| _1 = modifiers _2 = type_java _3 = variable_declarator_id _4 = for_var_control_rest
    {     ( canon_var _1 _2 _3, _4 )}

for_var_control_rest:
  _1 = COLON _2 = expression
    {                                       ( _2 )}

break_statement:
  _1 = BREAK _2 = identifier_opt _3 = SM
    {                                          ( Break _2 )}

continue_statement:
  _1 = CONTINUE _2 = identifier_opt _3 = SM
    {                                                ( Continue _2 )}

return_statement:
  _1 = RETURN _2 = expression_opt _3 = SM
    {                                            ( Return _2 )}

synchronized_statement:
  _1 = SYNCHRONIZED _2 = LP _3 = expression _4 = RP _5 = block
    {                                                            ( Sync (_3, _5) )}

throw_statement:
  _1 = THROW _2 = expression _3 = SM
    {                                      ( Throw _2 )}

try_statement:
  _1 = TRY _2 = block _3 = catches
    {                                  ( Try (_2, List.rev _3, None) )}
| _1 = TRY _2 = block _3 = catches_opt _4 = finally
    {                                  ( Try (_2, _3, Some _4) )}

catch_clause:
  _1 = CATCH _2 = LP _3 = formal_parameter _4 = RP _5 = block
    {                                       ( _3, _5 )}
| _1 = CATCH _2 = LP _3 = formal_parameter _4 = RP _5 = empty_statement
    {                                                 ( _3, _5 )}

finally:
  _1 = FINALLY _2 = block
    {                        ( _2 )}

statement_no_short_if:
  _1 = statement_without_trailing_substatement
    {                                            ( _1 )}
| _1 = labeled_statement_no_short_if
    {                                  ( _1 )}
| _1 = if_then_else_statement_no_short_if
    {                                       ( _1 )}
| _1 = while_statement_no_short_if
    {                                ( _1 )}
| _1 = for_statement_no_short_if
    {                              ( _1 )}

labeled_statement_no_short_if:
  _1 = identifier _2 = COLON _3 = statement_no_short_if
    {   ( Label (_1, _3) )}

if_then_else_statement_no_short_if:
  _1 = IF _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if _6 = ELSE _7 = statement_no_short_if
    {   ( If (_3, _5, _7) )}

while_statement_no_short_if:
  _1 = WHILE _2 = LP _3 = expression _4 = RP _5 = statement_no_short_if
    {     ( While (_3, _5) )}

for_statement_no_short_if:
  _1 = FOR _2 = LP _3 = for_control _4 = RP _5 = statement_no_short_if
    { ( For (_3, _5) )}

modifier:
  _1 = PUBLIC
    {                ( Public, _1 )}
| _1 = PROTECTED
    {                ( Protected, _1 )}
| _1 = PRIVATE
    {                ( Private, _1 )}
| _1 = ABSTRACT
    {                ( Abstract, _1 )}
| _1 = STATIC
    {                ( Static, _1 )}
| _1 = FINAL
    {                ( Final, _1 )}
| _1 = STRICTFP
    {                ( StrictFP, _1 )}
| _1 = TRANSIENT
    {                ( Transient, _1 )}
| _1 = VOLATILE
    {                ( Volatile, _1 )}
| _1 = SYNCHRONIZED
    {                ( Synchronized, _1 )}
| _1 = NATIVE
    {                ( Native, _1 )}
| _1 = annotation
    {              ( Annotation _1, (info_of_identifier_ (List.hd (List.rev (fst _1)))) )}

annotation:
  _1 = AT _2 = name
    {           ( (_2, None) )}
| _1 = AT _2 = name _3 = LP _4 = annotation_element _5 = RP
    {                                    ( (_2, Some _4) )}

annotation_element:
  
    {                 ( EmptyAnnotArg )}
| _1 = element_value
    {                 ( AnnotArgValue _1 )}
| _1 = element_value_pairs
    {                       ( AnnotArgPairInit _1 )}

element_value:
  _1 = expr1
    {         ( AnnotExprInit _1 )}
| _1 = annotation
    {              ( AnnotNestedAnnot _1 )}
| _1 = element_value_array_initializer
    {                                   ( AnnotArrayInit _1 )}

element_value_pair:
  _1 = identifier _2 = EQ _3 = element_value
    {                               ( (_1, _3) )}

element_value_array_initializer:
  _1 = LC _2 = RC
    {         ( [] )}
| _1 = LC _2 = element_values _3 = RC
    {                        ( _2 )}
| _1 = LC _2 = element_values _3 = CM _4 = RC
    {                           ( _2 )}

expr1:
  _1 = primary_no_new_array
    {                        ( _1 )}
| _1 = primary_no_new_array _2 = PLUS _3 = primary_no_new_array
    {                                                  ( failwith "+ inside raw annot values"  )}
| _1 = name
    {        ( NameOrClassType _1 )}

class_declaration:
  _1 = modifiers_opt _2 = CLASS _3 = identifier _4 = type_parameters_opt _5 = super_opt _6 = interfaces_opt _7 = class_body
    {  ( { cl_name = _3; cl_kind = ClassRegular;
      cl_mods = _1; cl_tparams = _4;
      cl_extends = _5;  cl_impls = _6;
      cl_body = _7;
     }
  )}

super:
  _1 = EXTENDS _2 = type_java
    {                          ( _2 )}

interfaces:
  _1 = IMPLEMENTS _2 = ref_type_list
    {                                      ( _2 )}

class_body:
  _1 = LC _2 = class_body_declarations_opt _3 = RC
    {                                               ( _2 )}

class_body_declaration:
  _1 = class_member_declaration
    {                             ( _1 )}
| _1 = constructor_declaration
    {                            ( [_1] )}
| _1 = instance_initializer
    {                         ( [_1] )}
| _1 = static_initializer
    {                       ( [_1] )}

class_member_declaration:
  _1 = field_declaration
    {                      ( _1 )}
| _1 = method_declaration
    {                       ( [Method _1] )}
| _1 = generic_method_or_constructor_decl
    {                                      ( ast_todo )}
| _1 = class_declaration
    {                      ( [Class _1] )}
| _1 = interface_declaration
    {                          ( [Class _1] )}
| _1 = enum_declaration
    {                    ( [Enum _1] )}
| _1 = annotation_type_declaration
    {                               ( ast_todo )}
| _1 = SM
    {       ( [] )}

field_declaration:
  _1 = modifiers_opt _2 = type_java _3 = variable_declarators _4 = SM
    {   ( decls (fun x -> Field x) _1 _2 (List.rev _3) )}

variable_declarator:
  _1 = variable_declarator_id
    {                           ( _1, None )}
| _1 = variable_declarator_id _2 = EQ _3 = variable_initializer
    {                                                   ( _1, Some _3 )}

variable_declarator_id:
  _1 = identifier
    {                                 ( IdentDecl _1 )}
| _1 = variable_declarator_id _2 = LB_RB
    {                                 ( ArrayDecl _1 )}

variable_initializer:
  _1 = expression
    {                      ( ExprInit _1 )}
| _1 = array_initializer
    {                      ( _1 )}

array_initializer:
  _1 = LC _2 = comma_opt _3 = RC
    {                                          ( ArrayInit [] )}
| _1 = LC _2 = variable_initializers _3 = comma_opt _4 = RC
    {                                          ( ArrayInit (List.rev _2) )}

method_declaration:
  _1 = method_header _2 = method_body
    {                                               ( { _1 with m_body = _2 } )}

method_header:
  _1 = modifiers_opt _2 = type_java _3 = method_declarator _4 = throws_opt
    {     ( method_header _1 _2 _3 _4 )}
| _1 = modifiers_opt _2 = VOID _3 = method_declarator _4 = throws_opt
    {     ( method_header _1 (void_type _2) _3 _4 )}

method_declarator:
  _1 = identifier _2 = LP _3 = formal_parameter_list_opt _4 = RP
    {                                               ( (IdentDecl _1), _3 )}
| _1 = method_declarator _2 = LB_RB
    {                                               ( (ArrayDecl (fst _1)), snd _1 )}

generic_method_or_constructor_decl:
  _1 = modifiers_opt _2 = type_parameters _3 = generic_method_or_constructor_rest
    {                                                                    ( )}

generic_method_or_constructor_rest:
  _1 = type_java _2 = identifier _3 = method_declarator_rest
    {                                               ( )}
| _1 = VOID _2 = identifier _3 = method_declarator_rest
    {                                          ( )}

method_declarator_rest:
  _1 = formal_parameters _2 = throws_opt _3 = method_body
    {                                            ( )}

formal_parameters:
  _1 = LP _2 = formal_parameter_list_opt _3 = RP
    {                                                   ( _2 )}

throws:
  _1 = THROWS _2 = qualified_ident_list
    {                                     ( _2 )}

method_body:
  _1 = block
    {          ( _1 )}
| _1 = SM
    {          ( Empty )}

instance_initializer:
  _1 = block
    {                                  ( Init (false, _1) )}

static_initializer:
  _1 = STATIC _2 = block
    {                                  ( Init (true, _2) )}

constructor_declaration:
  _1 = modifiers_opt _2 = constructor_declarator _3 = throws_opt _4 = constructor_body
    {  (
    let no_type = TBasic ("void", fakeInfo "void") in
    let (id, formals) = _2 in
    let var = { v_mods = _1; v_type = no_type; v_name = id } in
    Method { m_var = var; m_formals = formals; m_throws = _3;
	     m_body = _4 }
  )}

constructor_declarator:
  _1 = identifier _2 = LP _3 = formal_parameter_list_opt _4 = RP
    {                                                                    ( _1, _3 )}

constructor_body:
  _1 = LC _2 = block_statements_opt _3 = RC
    {                                                              ( Block _2 )}
| _1 = LC _2 = explicit_constructor_invocation _3 = block_statements_opt _4 = RC
    {                                                              ( Block (_2::_3) )}

explicit_constructor_invocation:
  _1 = THIS _2 = LP _3 = argument_list_opt _4 = RP _5 = SM
    {      ( constructor_invocation [this_ident _1] _3 )}
| _1 = SUPER _2 = LP _3 = argument_list_opt _4 = RP _5 = SM
    {      ( constructor_invocation [super_ident _1] _3 )}
| _1 = primary _2 = DOT _3 = SUPER _4 = LP _5 = argument_list_opt _6 = RP _7 = SM
    {      ( Expr (Call ((Dot (_1, super_identifier _3)), _5)) )}
| _1 = name _2 = DOT _3 = SUPER _4 = LP _5 = argument_list_opt _6 = RP _7 = SM
    {      ( constructor_invocation (name _1 @ [super_ident _3]) _5 )}

formal_parameter:
  _1 = variable_modifiers_opt _2 = type_java _3 = variable_declarator_id_bis
    {  ( canon_var _1 _2 _3 )}

variable_declarator_id_bis:
  _1 = variable_declarator_id
    {                               ( _1 )}
| _1 = DOTS _2 = variable_declarator_id
    {                               ( _2 (* todo_ast *) )}

variable_modifier:
  _1 = FINAL
    {              ( Final, _1 )}
| _1 = annotation
    {              ( (Annotation _1), info_of_identifier_ (List.hd (List.rev (fst _1))) )}

interface_declaration:
  _1 = modifiers_opt _2 = INTERFACE _3 = identifier _4 = type_parameters_opt _5 = extends_interfaces_opt _6 = interface_body
    {  ( { cl_name = _3; cl_kind = Interface;
      cl_mods = _1; cl_tparams = _4;
      cl_extends = None; cl_impls = _5;
      cl_body = _6;
    }
  )}

extends_interfaces:
  _1 = EXTENDS _2 = reference_type
    {                                         ( [_2] )}
| _1 = extends_interfaces _2 = CM _3 = reference_type
    {                                         ( _1 @ [_3] )}

interface_body:
  _1 = LC _2 = interface_member_declarations_opt _3 = RC
    {                                                         ( _2 )}

interface_member_declaration:
  _1 = constant_declaration
    {                         ( _1 )}
| _1 = abstract_method_declaration
    {                                ( [Method _1] )}
| _1 = interface_generic_method_decl
    {                                 ( ast_todo )}
| _1 = class_declaration
    {                          ( [Class _1] )}
| _1 = interface_declaration
    {                          ( [Class _1] )}
| _1 = enum_declaration
    {                          ( [Enum _1] )}
| _1 = annotation_type_declaration
    {                               ( ast_todo )}
| _1 = SM
    {       ( [] )}

constant_declaration:
  _1 = modifiers_opt _2 = type_java _3 = variable_declarators _4 = SM
    {     ( decls (fun x -> Field x) _1 _2 (List.rev _3) )}

abstract_method_declaration:
  _1 = modifiers_opt _2 = type_java _3 = method_declarator _4 = throws_opt _5 = SM
    { ( method_header _1 _2 _3 _4 )}
| _1 = modifiers_opt _2 = VOID _3 = method_declarator _4 = throws_opt _5 = SM
    { ( method_header _1 (void_type _2) _3 _4 )}

interface_generic_method_decl:
  _1 = modifiers_opt _2 = type_parameters _3 = type_java _4 = identifier _5 = interface_method_declator_rest
    {    ( ast_todo )}
| _1 = modifiers_opt _2 = type_parameters _3 = VOID _4 = identifier _5 = interface_method_declator_rest
    {    ( ast_todo )}

interface_method_declator_rest:
  _1 = formal_parameters _2 = throws_opt _3 = SM
    {                                   ( )}

enum_declaration:
  _1 = modifiers_opt _2 = ENUM _3 = identifier _4 = interfaces_opt _5 = enum_body
    {   ( { en_name = _3; en_mods = _1; en_impls = _4; en_body = _5; } )}

enum_body:
  _1 = LC _2 = enum_body_declarations_opt _3 = RC
    {                                                      ( [], _2 )}
| _1 = LC _2 = enum_constants _3 = enum_body_declarations_opt _4 = RC
    {                                                      ( _2, _3 )}
| _1 = LC _2 = enum_constants _3 = CM _4 = enum_body_declarations_opt _5 = RC
    {                                                      ( _2, _4 )}

enum_constant:
  _1 = identifier
    {                                      ( EnumSimple _1 )}
| _1 = identifier _2 = LP _3 = argument_list_opt _4 = RP
    {                                      ( EnumConstructor (_1, _3) )}
| _1 = identifier _2 = LC _3 = method_declarations_opt _4 = RC
    {                                             ( EnumWithMethods (_1, _3) )}

enum_body_declarations:
  _1 = SM _2 = class_body_declarations_opt
    {                                                       ( _2 )}

annotation_type_declaration:
  _1 = modifiers _2 = AT _3 = INTERFACE _4 = identifier _5 = annotation_type_body
    {                                                          ( ast_todo )}
| _1 = AT _2 = INTERFACE _3 = identifier _4 = annotation_type_body
    {                                                          ( ast_todo )}

annotation_type_body:
  _1 = LC _2 = annotation_type_element_declarations_opt _3 = RC
    {                                                                     ( )}

annotation_type_element_declaration:
  _1 = annotation_type_element_rest
    {                              ( )}

annotation_type_element_rest:
  _1 = modifiers_opt _2 = type_java _3 = identifier _4 = annotation_method_or_constant_rest _5 = SM
    {                                                                            ( )}
| _1 = class_declaration
    {                     ( )}
| _1 = enum_declaration
    {                    ( )}
| _1 = interface_declaration
    {                         ( )}
| _1 = annotation_type_declaration
    {                               (  )}

annotation_method_or_constant_rest:
  _1 = LP _2 = RP
    {         ( )}
| _1 = LP _2 = RP _3 = DEFAULT _4 = element_value
    {                               ( )}

annotation_type_element_declarations_opt:
  
    {   ( )}
| _1 = annotation_type_element_declarations
    {                                        ( )}

annotation_type_element_declarations:
  _1 = annotation_type_element_declaration
    {                                       ( )}
| _1 = annotation_type_element_declarations _2 = annotation_type_element_declaration
    {                                                                            ( )}

import_declarations:
  _1 = import_declaration
    {                       ( [_1] )}
| _1 = import_declarations _2 = import_declaration
    {                                           ( _1 @ [_2] )}

import_declarations_opt:
  
    {                  ( [] )}
| _1 = import_declarations
    {                        ( _1 )}

type_declarations:
  _1 = type_declaration
    {                     ( _1 )}
| _1 = type_declarations _2 = type_declaration
    {                                       ( _1 @ _2 )}

type_declarations_opt:
  
    {                  ( [] )}
| _1 = type_declarations
    {                      ( _1 )}

package_declaration_opt:
  
    {                  ( None )}
| _1 = package_declaration
    {                        ( Some _1 )}

modifiers:
  _1 = modifier
    {             ( [_1] )}
| _1 = modifiers _2 = modifier
    {                       ( _2 :: _1 )}

modifiers_opt:
  
    {                  ( [] )}
| _1 = modifiers
    {              ( List.rev _1 )}

super_opt:
  
    {                  ( None )}
| _1 = super
    {          ( Some _1 )}

interfaces_opt:
  
    {                  ( [] )}
| _1 = interfaces
    {               ( _1 )}

ref_type_list:
  _1 = reference_type
    {                   ( [_1] )}
| _1 = ref_type_list _2 = CM _3 = reference_type
    {                                    ( _1 @ [_3] )}

ref_type_and_list:
  _1 = reference_type
    {                   ( [_1] )}
| _1 = ref_type_and_list _2 = AND _3 = reference_type
    {                                         ( _1 @ [_3] )}

class_body_declarations:
  _1 = class_body_declaration
    {                           ( _1 )}
| _1 = class_body_declarations _2 = class_body_declaration
    {                                                   ( _1 @ _2 )}

class_body_declarations_opt:
  
    {                  ( [] )}
| _1 = class_body_declarations
    {                            ( _1 )}

variable_declarators:
  _1 = variable_declarator
    {                        ( [_1] )}
| _1 = variable_declarators _2 = CM _3 = variable_declarator
    {                                                ( _3 :: _1 )}

formal_parameter_list:
  _1 = formal_parameter
    {                     ( [_1] )}
| _1 = formal_parameter_list _2 = CM _3 = formal_parameter
    {                                              ( _3 :: _1 )}

formal_parameter_list_opt:
  
    {                  ( [] )}
| _1 = formal_parameter_list
    {                          ( List.rev _1 )}

variable_modifiers_opt:
  
    {                  ( [] )}
| _1 = variable_modifiers
    {                       ( _1 )}

variable_modifiers:
  _1 = variable_modifier
    {                     ( [_1] )}
| _1 = variable_modifiers _2 = variable_modifier
    {                                        ( _1 @ [_2] )}

static_opt:
  
    {                  ( false )}
| _1 = STATIC
    {           ( true )}

throws_opt:
  
    {                  ( [] )}
| _1 = throws
    {           ( _1 )}

qualified_ident_list:
  _1 = name
    {                                 ( [qualified_ident _1] )}
| _1 = qualified_ident_list _2 = CM _3 = name
    {                                 ( _1 @ [qualified_ident _3] )}

extends_interfaces_opt:
  
    {                  ( [] )}
| _1 = extends_interfaces
    {                       ( _1 )}

interface_member_declarations:
  _1 = interface_member_declaration
    {                                 ( _1 )}
| _1 = interface_member_declarations _2 = interface_member_declaration
    {                                                               ( _1 @ _2 )}

interface_member_declarations_opt:
  
    {                  ( [] )}
| _1 = interface_member_declarations
    {                                  ( _1 )}

variable_initializers:
  _1 = variable_initializer
    {                         ( [_1] )}
| _1 = variable_initializers _2 = CM _3 = variable_initializer
    {                                                  ( _3 :: _1 )}

comma_opt:
  
    {                  ( () )}
| _1 = CM
    {       ( () )}

block_statements:
  _1 = block_statement
    {                    ( _1 )}
| _1 = block_statements _2 = block_statement
    {                                     ( _1 @ _2 )}

block_statements_opt:
  
    {                      ( [] )}
| _1 = block_statements
    {                     ( _1 )}

switch_block_statement_groups:
  _1 = switch_block_statement_group
    {                                 ( [_1] )}
| _1 = switch_block_statement_groups _2 = switch_block_statement_group
    {                                                               ( _2 :: _1 )}

switch_labels:
  _1 = switch_label
    {                 ( [_1] )}
| _1 = switch_labels _2 = switch_label
    {                               ( _2 :: _1 )}

expression_opt:
  
    {                  ( None )}
| _1 = expression
    {                  ( Some _1 )}

for_update_opt:
  
    {                  ( [] )}
| _1 = for_update
    {                  ( _1 )}

statement_expression_list:
  _1 = statement_expression
    {                                                      ( [_1] )}
| _1 = statement_expression_list _2 = CM _3 = statement_expression
    {                                                      ( _1 @ [_3] )}

identifier_opt:
  
    {                  ( None )}
| _1 = identifier
    {               ( Some _1 )}

catches:
  _1 = catch_clause
    {                 ( [_1] )}
| _1 = catches _2 = catch_clause
    {                         ( _2 :: _1 )}

catches_opt:
  
    {                  ( [] )}
| _1 = catches
    {            ( List.rev _1 )}

argument_list:
  _1 = expression
    {               ( [_1] )}
| _1 = argument_list _2 = CM _3 = expression
    {                                ( _3 :: _1 )}

argument_list_opt:
  
    {                  ( [] )}
| _1 = argument_list
    {                  ( List.rev _1 )}

method_declarations_opt:
  
    {                  ( [] )}
| _1 = method_declarations
    {                        ( List.rev _1 )}

method_declarations:
  _1 = method_declaration
    {                      ( [_1] )}
| _1 = method_declarations _2 = method_declaration
    {                                          ( _2 :: _1 )}

class_body_opt:
  
    {                  ( None )}
| _1 = class_body
    {                  ( Some _1 )}

dim_exprs:
  _1 = dim_expr
    {             ( [_1] )}
| _1 = dim_exprs _2 = dim_expr
    {                       ( _2 :: _1 )}

dims_opt:
  
    {                  ( 0 )}
| _1 = dims
    {         ( _1 )}

enum_constants:
  _1 = enum_constant
    {                 ( [_1] )}
| _1 = enum_constants _2 = CM _3 = enum_constant
    {                                   ( _1 @ [_3] )}

enum_body_declarations_opt:
  
    {                           ( [] )}
| _1 = enum_body_declarations
    {                           ( _1 )}

type_parameters_opt:
  
    {                   ( [] )}
| _1 = type_parameters
    {                   ( _1 )}

type_parameters:
  _1 = LT _2 = type_parameters_bis _3 = GT
    {                             ( _2 )}

type_parameters_bis:
  _1 = type_parameter
    {                                          ( [_1] )}
| _1 = type_parameters_bis _2 = CM _3 = type_parameter
    {                                          ( _1 @ [_3] )}

type_arguments:
  _1 = type_argument
    {                                    ( [_1] )}
| _1 = type_arguments _2 = CM _3 = type_argument
    {                                    ( _1 @ [_3] )}

element_value_pairs:
  _1 = element_value_pair
    {                      ( [_1] )}
| _1 = element_value_pairs _2 = CM _3 = element_value_pair
    {                                             ( _1 @ [_3] )}

element_values:
  _1 = element_value
    {                 ( [_1] )}
| _1 = element_values _2 = CM _3 = element_value
    {                                   ( _1 @ [_3] )}

%%


